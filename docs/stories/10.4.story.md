# Story 10.4: 實作 AbstractOwaspRule AI 增強邏輯

<!-- Source: docs/prd/epic-10-ai-application-layer-enhancement.md -->

## Status

Draft

## Story

**As a** security rule developer,
**I want** AbstractOwaspRule to implement AI-powered violation enhancement logic,
**so that** all OWASP rules can leverage AI to provide intelligent fix suggestions with code examples and effort estimates.

## Epic Context

**Epic**: Epic 10 - AI 應用層增強與修復

**Prerequisites**:
- Story 10.1 完成（RuleViolation 資料結構擴展）
- Story 10.2 完成（OwaspSensor 保留完整 AI 資訊）
- Story 10.3 完成（基礎資訊傳遞測試）

**Background**: 根據 `docs/AI_APPLICATION_DESIGN_ANALYSIS.md` Section 2.3，所有 10 個 OWASP 規則的 `enhanceViolationsWithAi()` 方法都是空佔位符，未實際使用 AI。本 story 實作基礎類別的 AI 增強邏輯，供所有規則使用。

## Acceptance Criteria

1. **AC1**: 實作 `AbstractOwaspRule.enhanceViolationsWithAi()` 方法，包含：
   - 呼叫 `context.getAiService()` 取得 AI 服務
   - 對每個 violation 進行深入分析
   - 整合 AI 返回的 `fixSuggestion`、`codeExample`、`effortEstimate`
   - 返回增強後的 RuleViolation 清單

2. **AC2**: AI 服務呼叫邏輯：
   - 建構 AI 請求：包含代碼片段、規則資訊、OWASP 分類
   - 設定分析類型為 "vulnerability_enhancement"
   - 傳遞現有 violation 的上下文資訊
   - 解析 AI 回應並提取增強資訊

3. **AC3**: 錯誤處理與優雅降級：
   - AI 服務不可用：記錄警告，返回原始 violations
   - AI 呼叫超時：記錄警告，返回原始 violations
   - AI 返回無效資料：記錄錯誤，返回原始 violations
   - 部分 violations 增強失敗：成功的仍返回增強版本，失敗的返回原始版本

4. **AC4**: 快取機制實作：
   - 使用代碼片段 hash 作為快取 key
   - 快取 AI 增強結果避免重複呼叫
   - 快取有效期：1 小時（可配置）
   - 快取大小限制：最多 1000 個條目
   - 提供清空快取的方法（測試用）

5. **AC5**: 效能優化：
   - 批次處理：相同檔案的 violations 批次呼叫 AI
   - 異步處理：考慮使用異步 AI 呼叫（可選）
   - 超時控制：單次 AI 呼叫最多 30 秒
   - 並行限制：最多 3 個並行 AI 請求

6. **AC6**: 單元測試覆蓋率 ≥ 85%：
   - 測試 AI 成功增強的情況
   - 測試 AI 失敗的各種錯誤情境
   - 測試快取機制正常運作
   - 測試批次處理邏輯
   - 測試效能優化措施

## Integration Verification

**IV1**: 執行 `rules-engine` 模組的單元測試，確認所有測試通過且覆蓋率 ≥ 85%。
```bash
mvn clean test -pl rules-engine
mvn jacoco:report -pl rules-engine
```

**IV2**: 整合測試：使用真實 AI 服務測試一個完整規則的 AI 增強流程。

**IV3**: 效能測試：測試 100 個 violations 的增強處理時間，確認 <30 秒完成。

**IV4**: 快取測試：驗證相同代碼片段的第二次呼叫直接使用快取結果。

## Tasks / Subtasks

- [ ] **Task 1**: 設計 AI 增強流程架構（AC1, AC2）
  - [ ] 分析現有 `enhanceViolationsWithAi()` 簽名和呼叫點
  - [ ] 設計 AI 請求建構邏輯
  - [ ] 設計 AI 回應解析邏輯
  - [ ] 設計增強後的 RuleViolation 建構邏輯
  - [ ] 繪製 AI 增強流程圖（存入 Dev Notes）

- [ ] **Task 2**: 實作 AI 請求建構器（AC2）
  - [ ] 創建 `AiEnhancementRequest` 資料類別
  - [ ] 實作 `buildEnhancementRequest()` 方法：
    - [ ] 包含代碼片段（violation 所在行 ± 10 行）
    - [ ] 包含規則資訊（ruleKey, name, description）
    - [ ] 包含 OWASP 分類和 CWE ID
    - [ ] 包含現有 violation 訊息作為上下文
  - [ ] 設定 analysisType = "vulnerability_enhancement"
  - [ ] 單元測試：驗證請求建構正確

- [ ] **Task 3**: 實作 AI 回應解析器（AC2）
  - [ ] 創建 `parseEnhancementResponse()` 方法
  - [ ] 解析 AI 返回的 `fixSuggestion`
  - [ ] 解析 AI 返回的 `codeExample`（before/after）
  - [ ] 解析 AI 返回的 `effortEstimate`
  - [ ] 驗證回應完整性和有效性
  - [ ] 單元測試：測試各種 AI 回應格式

- [ ] **Task 4**: 實作核心 enhanceViolationsWithAi 方法（AC1）
  - [ ] 移除現有的空佔位符實作
  - [ ] 實作主要邏輯：
    - [ ] 檢查 AI 服務是否可用
    - [ ] 遍歷每個 violation
    - [ ] 建構 AI 請求
    - [ ] 呼叫 AI 服務
    - [ ] 解析 AI 回應
    - [ ] 建構增強後的 RuleViolation
  - [ ] 使用 Builder 模式建構增強後的 violation
  - [ ] 單元測試：測試成功增強流程

- [ ] **Task 5**: 實作錯誤處理邏輯（AC3）
  - [ ] Try-catch 包裝 AI 服務呼叫
  - [ ] 處理 `AiException`（AI 服務異常）
  - [ ] 處理 `TimeoutException`（超時）
  - [ ] 處理 `IllegalStateException`（無效回應）
  - [ ] 記錄適當的日誌層級：
    - [ ] WARN：AI 服務不可用或超時
    - [ ] ERROR：無效回應或解析錯誤
    - [ ] DEBUG：成功增強的詳細資訊
  - [ ] 單元測試：測試各種錯誤情境

- [ ] **Task 6**: 實作優雅降級機制（AC3）
  - [ ] AI 服務不可用時，返回原始 violations
  - [ ] AI 呼叫失敗時，返回原始 violations
  - [ ] 部分增強失敗時，返回混合清單（成功 + 原始）
  - [ ] 確保降級不影響掃描流程繼續
  - [ ] 單元測試：驗證降級行為正確

- [ ] **Task 7**: 實作快取機制（AC4）
  - [ ] 選擇快取實作：使用 Caffeine Cache
  - [ ] 創建 `EnhancementCache` 類別：
    - [ ] 定義快取 key 策略（代碼片段 hash）
    - [ ] 設定快取大小限制（1000 條目）
    - [ ] 設定快取過期時間（1 小時）
    - [ ] 實作 `get()` 方法
    - [ ] 實作 `put()` 方法
    - [ ] 實作 `clear()` 方法（測試用）
  - [ ] 在 `enhanceViolationsWithAi()` 中整合快取邏輯
  - [ ] 單元測試：測試快取命中和未命中情況

- [ ] **Task 8**: 實作批次處理優化（AC5）
  - [ ] 分析批次處理可行性（AI API 是否支援）
  - [ ] 如果支援，實作批次請求邏輯：
    - [ ] 將相同檔案的 violations 分組
    - [ ] 建構批次 AI 請求
    - [ ] 批次呼叫 AI 服務
    - [ ] 解析批次回應並對應到各個 violation
  - [ ] 如果不支援，實作並行處理：
    - [ ] 使用 ExecutorService 並行處理
    - [ ] 限制並行數量（最多 3 個）
    - [ ] 等待所有請求完成
  - [ ] 單元測試：測試批次/並行處理邏輯

- [ ] **Task 9**: 實作超時控制（AC5）
  - [ ] 設定單次 AI 呼叫超時為 30 秒
  - [ ] 使用 CompletableFuture 或類似機制實作超時
  - [ ] 超時後取消 AI 請求
  - [ ] 記錄超時警告
  - [ ] 返回原始 violation（降級）
  - [ ] 單元測試：測試超時處理

- [ ] **Task 10**: 撰寫輔助方法
  - [ ] `extractCodeSnippet()`: 提取代碼片段（± 10 行）
  - [ ] `calculateCodeHash()`: 計算代碼片段 hash
  - [ ] `isAiServiceAvailable()`: 檢查 AI 服務可用性
  - [ ] `buildEnhancedViolation()`: 建構增強後的 violation
  - [ ] 單元測試：測試每個輔助方法

- [ ] **Task 11**: 撰寫單元測試（AC6）
  - [ ] **成功增強測試**:
    - [ ] 測試單個 violation 增強
    - [ ] 測試多個 violations 批次增強
    - [ ] 驗證增強後的欄位正確設定
  - [ ] **錯誤處理測試**:
    - [ ] 測試 AI 服務不可用
    - [ ] 測試 AI 呼叫超時
    - [ ] 測試 AI 返回無效資料
    - [ ] 測試部分 violations 增強失敗
  - [ ] **快取測試**:
    - [ ] 測試快取命中（相同代碼片段）
    - [ ] 測試快取未命中（不同代碼片段）
    - [ ] 測試快取過期
    - [ ] 測試快取大小限制
  - [ ] **效能測試**:
    - [ ] 測試批次處理效能
    - [ ] 測試並行處理效能
    - [ ] 測試超時控制

- [ ] **Task 12**: 更新 Javadoc 和註釋
  - [ ] 更新 `enhanceViolationsWithAi()` 方法的 Javadoc
  - [ ] 說明參數、返回值、例外情況
  - [ ] 提供使用範例
  - [ ] 說明快取機制和效能考量
  - [ ] 新增程式碼註釋說明關鍵邏輯

- [ ] **Task 13**: 執行整合驗證（IV1-IV4）
  - [ ] 執行 `mvn clean test -pl rules-engine`
  - [ ] 檢查測試覆蓋率報告（≥ 85%）
  - [ ] 執行整合測試：使用真實 AI 服務
  - [ ] 執行效能測試：100 violations < 30 秒
  - [ ] 執行快取測試：驗證快取正常運作
  - [ ] 修復發現的問題

## Dev Notes

### 檔案位置

**主要修改檔案**:
- `rules-engine/src/main/java/com/github/sonarqube/rules/AbstractOwaspRule.java`
  - Line 255-263: `enhanceViolationsWithAi()` 方法（需完整實作）

**新增檔案**（建議）:
- `rules-engine/src/main/java/com/github/sonarqube/rules/enhancement/AiEnhancementRequest.java`
  - AI 增強請求資料類別
- `rules-engine/src/main/java/com/github/sonarqube/rules/enhancement/EnhancementCache.java`
  - AI 增強結果快取
- `rules-engine/src/main/java/com/github/sonarqube/rules/enhancement/AiEnhancementService.java`
  - AI 增強服務（封裝增強邏輯）

**測試檔案** (需創建):
- `rules-engine/src/test/java/com/github/sonarqube/rules/AbstractOwaspRuleTest.java`
  - 測試 AI 增強邏輯
- `rules-engine/src/test/java/com/github/sonarqube/rules/enhancement/EnhancementCacheTest.java`
  - 測試快取機制

### 設計考量

**1. AI 增強流程架構**:

```
┌─────────────────────────────────────────────────────────────┐
│ enhanceViolationsWithAi(RuleContext, List<RuleViolation>)   │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
            ┌───────────────────────────────┐
            │ Check AI Service Availability │
            └───────────────────────────────┘
                            │
                            ▼
            ┌───────────────────────────────┐
            │ For each violation:           │
            │ 1. Calculate code hash        │
            │ 2. Check cache               │
            │ 3. If miss, call AI          │
            │ 4. Parse response            │
            │ 5. Build enhanced violation  │
            │ 6. Update cache              │
            └───────────────────────────────┘
                            │
                            ▼
            ┌───────────────────────────────┐
            │ Return enhanced violations    │
            │ (or original if AI fails)     │
            └───────────────────────────────┘
```

**2. AI 請求建構策略**:

```java
protected AiRequest buildEnhancementRequest(
    RuleViolation violation,
    String sourceCode,
    RuleContext context
) {
    // 提取代碼片段（violation 所在行 ± 10 行）
    String codeSnippet = extractCodeSnippet(sourceCode, violation.getLineNumber(), 10);

    // 建構增強請求
    return AiRequest.builder(codeSnippet)
        .analysisType("vulnerability_enhancement")
        .language(context.getLanguage())
        .fileName(context.getFileName())
        .owaspVersion(context.getOwaspVersion())
        .metadata(Map.of(
            "ruleKey", getRuleKey(),
            "ruleName", getName(),
            "owaspCategory", getOwaspCategory().getCategoryId(),
            "cweIds", String.join(",", getCweIds()),
            "existingMessage", violation.getMessage()
        ))
        .build();
}
```

**3. 快取 Key 策略**:

使用代碼片段內容和規則資訊的組合 hash：

```java
private String calculateCacheKey(String codeSnippet, String ruleKey) {
    String combined = ruleKey + ":" + codeSnippet.trim();
    return DigestUtils.sha256Hex(combined); // 使用 SHA-256
}
```

**快取結構**:
```java
public class EnhancementCache {
    private final Cache<String, EnhancedData> cache;

    public EnhancementCache() {
        this.cache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(1, TimeUnit.HOURS)
            .recordStats()
            .build();
    }

    public static class EnhancedData {
        private final String fixSuggestion;
        private final CodeExample codeExample;
        private final String effortEstimate;
        // + getters
    }
}
```

**4. 錯誤處理策略**:

**分層錯誤處理**:
- **AI 服務層**：拋出 `AiException`
- **增強服務層**：捕獲 `AiException`，記錄日誌，返回 Optional.empty()
- **規則層**：檢查 Optional，如果為空則返回原始 violation

**錯誤場景處理**:
```java
protected List<RuleViolation> enhanceViolationsWithAi(
    RuleContext context,
    List<RuleViolation> violations
) {
    if (!context.isAiServiceAvailable()) {
        LOG.warn("AI service not available, returning original violations");
        return violations;
    }

    List<RuleViolation> enhanced = new ArrayList<>();

    for (RuleViolation violation : violations) {
        try {
            Optional<EnhancedData> enhancedData = enhanceWithAi(violation, context);
            if (enhancedData.isPresent()) {
                enhanced.add(buildEnhancedViolation(violation, enhancedData.get()));
            } else {
                enhanced.add(violation); // Fallback to original
            }
        } catch (Exception e) {
            LOG.error("Failed to enhance violation: {}", e.getMessage());
            enhanced.add(violation); // Fallback to original
        }
    }

    return enhanced;
}
```

**5. 批次處理 vs 並行處理**:

**選項 A**: 批次處理（如果 AI API 支援）
- 優點：減少 API 呼叫次數，更高效
- 缺點：需要 AI API 支援批次請求

**選項 B**: 並行處理
- 優點：無需 AI API 支援批次，簡單可靠
- 缺點：需要控制並行數量，避免過載

**建議**: 優先使用選項 B（並行處理），更通用且易於實作。

**並行處理實作**:
```java
protected List<RuleViolation> enhanceViolationsWithAi(
    RuleContext context,
    List<RuleViolation> violations
) {
    if (violations.isEmpty()) return violations;

    ExecutorService executor = Executors.newFixedThreadPool(3); // Max 3 concurrent
    List<Future<RuleViolation>> futures = new ArrayList<>();

    for (RuleViolation violation : violations) {
        futures.add(executor.submit(() -> {
            try {
                return enhanceSingleViolation(violation, context);
            } catch (Exception e) {
                LOG.error("Enhancement failed: {}", e.getMessage());
                return violation; // Fallback
            }
        }));
    }

    List<RuleViolation> enhanced = new ArrayList<>();
    for (Future<RuleViolation> future : futures) {
        try {
            enhanced.add(future.get(30, TimeUnit.SECONDS)); // 30s timeout
        } catch (TimeoutException e) {
            LOG.warn("Enhancement timeout, using original violation");
            enhanced.add(violations.get(futures.indexOf(future)));
        } catch (Exception e) {
            LOG.error("Enhancement error: {}", e.getMessage());
            enhanced.add(violations.get(futures.indexOf(future)));
        }
    }

    executor.shutdown();
    return enhanced;
}
```

**6. 效能優化考量**:

**快取優先級**:
- ✅ 高優先級：快取機制（避免重複 AI 呼叫）
- ✅ 中優先級：並行處理（提升吞吐量）
- ⚠️ 低優先級：異步處理（複雜度高，可選）

**效能目標**:
- 100 violations 處理時間：< 30 秒
- 快取命中率：≥ 70%（相同專案多次掃描）
- 並行數量：3 個（平衡效能與資源）

### 參考資料

**相關類別**:
- `rules-engine/src/main/java/com/github/sonarqube/rules/AbstractOwaspRule.java`
  - Line 255-263: 空佔位符 `enhanceViolationsWithAi()`
- `rules-engine/src/main/java/com/github/sonarqube/rules/RuleContext.java`
  - `getAiService()` 方法
- `ai-connector/src/main/java/com/github/sonarqube/ai/AiService.java`
  - AI 服務介面
- `rules-engine/src/main/java/com/github/sonarqube/rules/RuleResult.java`
  - Line 215-251: `ViolationBuilder` 類別

**相關分析報告**:
- `docs/AI_APPLICATION_DESIGN_ANALYSIS.md` - Section 2.3（規則引擎未使用 AI）
- `docs/AI_APPLICATION_DESIGN_ANALYSIS.md` - Section 7.2（修復建議 Phase 2）

**快取庫文檔**:
- Caffeine Cache: https://github.com/ben-manes/caffeine

### Testing

**測試檔案位置**: `rules-engine/src/test/java/com/github/sonarqube/rules/`

**測試框架**:
- JUnit 5 (Jupiter)
- AssertJ (流暢的斷言 API)
- Mockito (mock AiService, RuleContext)
- Awaitility (測試異步邏輯，如需要)

**測試標準**:
- 單元測試覆蓋率目標: ≥ 85%
- 測試命名: `methodName_scenario_expectedBehavior`
- 測試組織: Arrange-Act-Assert (AAA) 模式
- 每個 AC 至少對應 2 個測試案例

**關鍵測試場景**:

1. **成功增強測試**:
```java
@Test
void enhanceViolationsWithAi_withValidAiResponse_shouldReturnEnhancedViolations() {
    // Arrange
    RuleViolation originalViolation = createTestViolation();
    AiService mockAiService = mock(AiService.class);
    RuleContext mockContext = createMockContextWithAiService(mockAiService);

    // Mock AI response with complete enhancement data
    SecurityIssue enhancedIssue = createEnhancedSecurityIssue();
    when(mockAiService.analyzeCode(any())).thenReturn(
        AiResponse.builder()
            .issues(List.of(enhancedIssue))
            .success(true)
            .build()
    );

    // Act
    List<RuleViolation> result = rule.enhanceViolationsWithAi(mockContext, List.of(originalViolation));

    // Assert
    assertThat(result).hasSize(1);
    RuleViolation enhanced = result.get(0);

    assertThat(enhanced.getFixSuggestion()).isNotBlank();
    assertThat(enhanced.getCodeExample()).isNotNull();
    assertThat(enhanced.getCodeExample().getBefore()).isNotBlank();
    assertThat(enhanced.getCodeExample().getAfter()).isNotBlank();
    assertThat(enhanced.getEffortEstimate()).isNotBlank();

    // Verify AI service was called
    verify(mockAiService).analyzeCode(argThat(request ->
        request.getAnalysisType().equals("vulnerability_enhancement")
    ));
}
```

2. **AI 服務不可用測試**:
```java
@Test
void enhanceViolationsWithAi_whenAiServiceUnavailable_shouldReturnOriginalViolations() {
    // Arrange
    RuleViolation originalViolation = createTestViolation();
    RuleContext mockContext = createMockContextWithoutAiService();

    // Act
    List<RuleViolation> result = rule.enhanceViolationsWithAi(mockContext, List.of(originalViolation));

    // Assert
    assertThat(result).hasSize(1);
    assertThat(result.get(0)).isSameAs(originalViolation); // Same instance, not enhanced
}
```

3. **AI 呼叫超時測試**:
```java
@Test
void enhanceViolationsWithAi_whenAiCallTimesOut_shouldFallbackToOriginal() {
    // Arrange
    RuleViolation originalViolation = createTestViolation();
    AiService mockAiService = mock(AiService.class);
    RuleContext mockContext = createMockContextWithAiService(mockAiService);

    // Mock AI timeout
    when(mockAiService.analyzeCode(any()))
        .thenThrow(new TimeoutException("AI service timeout"));

    // Act
    List<RuleViolation> result = rule.enhanceViolationsWithAi(mockContext, List.of(originalViolation));

    // Assert
    assertThat(result).hasSize(1);
    assertThat(result.get(0)).isEqualTo(originalViolation);
    // Verify warning was logged
}
```

4. **快取測試**:
```java
@Test
void enhanceViolationsWithAi_withSameCodeSnippet_shouldUseCachedResult() {
    // Arrange
    RuleViolation violation1 = createTestViolation("same code");
    RuleViolation violation2 = createTestViolation("same code");
    AiService mockAiService = mock(AiService.class);
    RuleContext mockContext = createMockContextWithAiService(mockAiService);

    when(mockAiService.analyzeCode(any()))
        .thenReturn(createMockAiResponse());

    // Act
    List<RuleViolation> result1 = rule.enhanceViolationsWithAi(mockContext, List.of(violation1));
    List<RuleViolation> result2 = rule.enhanceViolationsWithAi(mockContext, List.of(violation2));

    // Assert
    assertThat(result1).hasSize(1);
    assertThat(result2).hasSize(1);

    // Verify AI service called only once (second call used cache)
    verify(mockAiService, times(1)).analyzeCode(any());
}
```

5. **批次處理測試**:
```java
@Test
void enhanceViolationsWithAi_withMultipleViolations_shouldProcessInParallel() {
    // Arrange
    List<RuleViolation> violations = IntStream.range(0, 10)
        .mapToObj(i -> createTestViolation("code " + i))
        .collect(Collectors.toList());

    AiService mockAiService = mock(AiService.class);
    RuleContext mockContext = createMockContextWithAiService(mockAiService);

    when(mockAiService.analyzeCode(any()))
        .thenReturn(createMockAiResponse());

    // Act
    long startTime = System.currentTimeMillis();
    List<RuleViolation> result = rule.enhanceViolationsWithAi(mockContext, violations);
    long elapsedTime = System.currentTimeMillis() - startTime;

    // Assert
    assertThat(result).hasSize(10);
    // Verify parallel processing (should be faster than sequential)
    // If sequential: 10 * 1000ms = 10000ms
    // If parallel (3 threads): ~4000ms (10/3 * 1000ms + overhead)
    assertThat(elapsedTime).isLessThan(7000); // Allow some overhead
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | 初始 Story 建立 | Scrum Master (Bob) |

## Dev Agent Record

<!-- This section will be populated by the Dev Agent during implementation -->

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

<!-- This section will be populated by the QA Agent -->

_To be filled by QA Agent_
