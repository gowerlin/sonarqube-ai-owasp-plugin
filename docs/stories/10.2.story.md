# Story 10.2: 修改 OwaspSensor 保留完整 AI 資訊

<!-- Source: docs/prd/epic-10-ai-application-layer-enhancement.md -->

## Status

Draft

## Story

**As a** developer implementing AI-enhanced security analysis,
**I want** OwaspSensor to preserve complete AI-provided information instead of discarding code examples and effort estimates,
**so that** end users can see Before/After code comparisons and effort estimations in SonarQube issues.

## Epic Context

**Epic**: Epic 10 - AI 應用層增強與修復

**Prerequisites**:
- Epic 2 Story 2.1-2.3 完成（AI 連接器、OpenAI 整合、提示詞工程）
- Epic 3 Story 3.1-3.2 完成（規則引擎架構、OWASP 2021 規則）
- Story 10.1 完成（RuleViolation 已擴展支援 codeExample 和 effortEstimate）

**Background**: 根據 `docs/AI_APPLICATION_DESIGN_ANALYSIS.md` Section 2.2，`OwaspSensor.buildIssueMessage()` 將 AI 提供的完整資訊簡化為純文字，導致 `codeExample` 和 `effortEstimate` 完全丟失。

## Acceptance Criteria

1. **AC1**: 重構 `buildIssueMessage()` 方法為 `buildEnhancedIssue()`，返回完整的 Issue 物件而非純文字。

2. **AC2**: 使用 SonarQube Issue Attributes API 儲存額外資訊：
   - Attribute: `ai.code.before` → codeExample.before
   - Attribute: `ai.code.after` → codeExample.after
   - Attribute: `ai.effort.estimate` → effortEstimate
   - Attribute: `ai.enhanced` → "true" (標記為 AI 增強)

3. **AC3**: 保留向後相容性：
   - 如果 SonarQube 版本不支援 Attributes API，優雅降級到純文字訊息
   - 版本檢測邏輯：檢查 SonarQube API 版本 ≥ 9.0
   - 降級模式仍保留 description 和 fixSuggestion

4. **AC4**: 整合測試驗證：
   - 測試 SecurityIssue → RuleViolation → SonarQube Issue 的完整流動
   - 驗證 Attributes 正確儲存和讀取
   - 測試降級模式正常運作

5. **AC5**: 錯誤處理：
   - Attribute 設定失敗時記錄警告但不中斷流程
   - 空值處理：codeExample 或 effortEstimate 為 null 時略過該 Attribute
   - 字串長度限制：超過 4000 字元時截斷並記錄警告

6. **AC6**: 效能要求：
   - Attribute 設定不導致 >10% 的效能衰退
   - 批次處理：多個 Issues 時避免重複版本檢測

## Integration Verification

**IV1**: 執行 `plugin-core` 模組的整合測試，確認 AI 資訊完整傳遞到 SonarQube。

**IV2**: 手動測試：使用 SonarQube API 查詢 Issue，驗證 Attributes 存在且內容正確。
```bash
curl -u admin:password "http://localhost:9000/api/issues/search?componentKeys=PROJECT_KEY" | jq '.issues[0].attributes'
```

**IV3**: 降級測試：在不支援 Attributes 的 SonarQube 版本（如 8.x）上測試，確認降級邏輯正常運作。

**IV4**: 端到端測試：從 AI 分析到 SonarQube UI 顯示的完整流程驗證。

## Tasks / Subtasks

- [ ] **Task 1**: 重構 buildIssueMessage 為 buildEnhancedIssue（AC1）
  - [ ] 修改方法簽名：返回 `NewIssue` 而非 `String`
  - [ ] 更新呼叫點：`reportIssues()` 方法中的使用
  - [ ] 保留原有訊息建構邏輯作為基礎訊息
  - [ ] 更新 Javadoc 說明新方法的用途

- [ ] **Task 2**: 實作 SonarQube 版本檢測（AC3）
  - [ ] 創建 `SonarQubeVersionDetector` 工具類別
  - [ ] 實作 `supportsAttributes()` 方法檢測 API 版本
  - [ ] 在 OwaspSensor 初始化時執行一次檢測
  - [ ] 快取檢測結果避免重複查詢
  - [ ] 單元測試：測試不同版本號的判斷邏輯

- [ ] **Task 3**: 實作 Attributes 設定邏輯（AC2）
  - [ ] 在 `buildEnhancedIssue()` 中新增 Attribute 設定區塊
  - [ ] 設定 `ai.code.before`（如果 codeExample 不為 null）
  - [ ] 設定 `ai.code.after`（如果 codeExample 不為 null）
  - [ ] 設定 `ai.effort.estimate`（如果 effortEstimate 不為 null）
  - [ ] 設定 `ai.enhanced = "true"` 標記
  - [ ] 實作字串長度檢查和截斷邏輯（>4000 字元）

- [ ] **Task 4**: 實作向後相容降級邏輯（AC3）
  - [ ] 創建 `buildLegacyIssueMessage()` 方法處理舊版本
  - [ ] 在 `buildEnhancedIssue()` 中根據版本檢測選擇邏輯
  - [ ] 確保降級模式仍包含 description 和 fixSuggestion
  - [ ] 測試降級邏輯：模擬不支援 Attributes 的環境

- [ ] **Task 5**: 錯誤處理與日誌記錄（AC5）
  - [ ] Try-catch 包裝 Attribute 設定邏輯
  - [ ] 記錄 WARN 日誌當 Attribute 設定失敗
  - [ ] 記錄 WARN 日誌當字串被截斷
  - [ ] 確保錯誤不影響 Issue 的建立
  - [ ] 單元測試：測試各種錯誤情境

- [ ] **Task 6**: 更新 reportIssues 方法（AC1）
  - [ ] 修改 `reportIssues()` 方法使用新的 `buildEnhancedIssue()`
  - [ ] 移除舊的 `buildIssueMessage()` 呼叫
  - [ ] 確保 NewIssueLocation 仍正確設定
  - [ ] 驗證 Issue 的其他屬性（severity, ruleKey 等）不受影響

- [ ] **Task 7**: 撰寫整合測試（AC4）
  - [ ] 測試完整流程：AI → SecurityIssue → RuleViolation → Issue with Attributes
  - [ ] 測試 Attributes 正確儲存和讀取
  - [ ] 測試空值處理：codeExample 或 effortEstimate 為 null
  - [ ] 測試字串截斷：超長文字處理
  - [ ] 測試降級模式：在不支援 Attributes 時的行為
  - [ ] 測試錯誤處理：Attribute 設定失敗時的行為

- [ ] **Task 8**: 效能測試與優化（AC6）
  - [ ] 基準測試：測量修改前後的效能差異
  - [ ] 快取版本檢測結果
  - [ ] 批次處理優化：避免重複版本檢測
  - [ ] 確認效能衰退 <10%
  - [ ] 記錄效能測試結果

- [ ] **Task 9**: 更新 Javadoc 和註釋
  - [ ] 為 `buildEnhancedIssue()` 新增詳細 Javadoc
  - [ ] 說明 Attributes 的用途和格式
  - [ ] 說明降級邏輯的觸發條件
  - [ ] 更新 OwaspSensor 類別的整體說明
  - [ ] 新增程式碼註釋說明關鍵邏輯

- [ ] **Task 10**: 執行整合驗證（IV1-IV4）
  - [ ] 執行 `mvn clean verify -pl plugin-core`
  - [ ] 手動測試：使用 SonarQube API 查詢 Attributes
  - [ ] 降級測試：在 SonarQube 8.x 環境測試
  - [ ] 端到端測試：完整掃描流程驗證
  - [ ] 修復發現的問題

## Dev Notes

### 檔案位置

**主要修改檔案**:
- `plugin-core/src/main/java/com/github/sonarqube/plugin/OwaspSensor.java`
  - Line 186-223: `reportIssues()` 方法
  - Line 286-300: `buildIssueMessage()` 方法（需重構）

**新增檔案**（建議）:
- `plugin-core/src/main/java/com/github/sonarqube/plugin/util/SonarQubeVersionDetector.java`
  - 版本檢測工具類別

**測試檔案** (需創建):
- `plugin-core/src/test/java/com/github/sonarqube/plugin/OwaspSensorTest.java`
  - 測試 AI 資訊傳遞邏輯
- `plugin-core/src/test/java/com/github/sonarqube/plugin/util/SonarQubeVersionDetectorTest.java`
  - 測試版本檢測邏輯

### 設計考量

**1. SonarQube Attributes API**:

SonarQube 9.0+ 支援 Issue Attributes，允許儲存額外的鍵值對資訊。

**API 使用範例**:
```java
NewIssue newIssue = context.newIssue();
newIssue.forRule(RuleKey.of(repositoryKey, rule.getRuleKey()));

NewIssueLocation location = newIssue.newLocation()
    .on(file)
    .message(buildBasicMessage(issue, rule));

if (issue.getLineNumber() != null && issue.getLineNumber() > 0) {
    location.at(file.selectLine(issue.getLineNumber()));
}

newIssue.at(location);

// 設定 Attributes（SonarQube 9.0+ 支援）
if (supportsAttributes()) {
    if (issue.getCodeExample() != null) {
        newIssue.attribute("ai.code.before", truncate(issue.getCodeExample().getBefore(), 4000));
        newIssue.attribute("ai.code.after", truncate(issue.getCodeExample().getAfter(), 4000));
    }
    if (issue.getEffortEstimate() != null) {
        newIssue.attribute("ai.effort.estimate", issue.getEffortEstimate());
    }
    newIssue.attribute("ai.enhanced", "true");
}

newIssue.save();
```

**2. 版本檢測策略**:

**選項 A**: 使用 SonarQube API 版本號檢測
- 優點：準確可靠
- 缺點：需要額外 API 呼叫

**選項 B**: Try-Catch 動態檢測
- 優點：無需預先檢測
- 缺點：第一次呼叫會產生例外

**建議**: 採用選項 A，在 OwaspSensor 初始化時執行一次檢測並快取結果。

**版本檢測實作**:
```java
public class SonarQubeVersionDetector {
    private static Boolean supportsAttributes = null;

    public static boolean supportsAttributes(SensorContext context) {
        if (supportsAttributes == null) {
            try {
                // 檢查 SonarQube Runtime API 版本
                org.sonar.api.SonarRuntime runtime = context.runtime();
                org.sonar.api.utils.Version version = runtime.getApiVersion();
                // Attributes API 從 SonarQube 9.0 開始支援
                supportsAttributes = version.isGreaterThanOrEqual(org.sonar.api.utils.Version.create(9, 0));
            } catch (Exception e) {
                // 如果檢測失敗，預設為不支援
                supportsAttributes = false;
            }
        }
        return supportsAttributes;
    }
}
```

**3. 向後相容性**:

**降級邏輯**:
- SonarQube ≥ 9.0: 使用 Attributes 儲存完整資訊
- SonarQube < 9.0: 降級為純文字訊息（包含 description 和 fixSuggestion）

**降級訊息格式**:
```
[Rule Name]: [Description]
建議: [Fix Suggestion]
程式碼範例（修復前）: [Code Before]
程式碼範例（修復後）: [Code After]
工作量評估: [Effort Estimate]
```

**4. 字串長度限制**:

SonarQube Attributes 可能有長度限制（通常為 4000 字元）。需要實作截斷邏輯：

```java
private String truncate(String text, int maxLength) {
    if (text == null) return null;
    if (text.length() <= maxLength) return text;

    LOG.warn("文字長度 {} 超過限制 {}，將被截斷", text.length(), maxLength);
    return text.substring(0, maxLength - 3) + "...";
}
```

**5. 效能考量**:

- 版本檢測快取：避免每個 Issue 都重複檢測
- Attribute 設定批次化：考慮使用批次 API（如果可用）
- 錯誤處理輕量化：避免過度日誌記錄影響效能

### 參考資料

**SonarQube Plugin API 文檔**:
- `org.sonar.api.batch.sensor.issue.NewIssue`
- `org.sonar.api.batch.sensor.issue.NewIssueLocation`
- `org.sonar.api.SonarRuntime`
- `org.sonar.api.utils.Version`

**相關分析報告**:
- `docs/AI_APPLICATION_DESIGN_ANALYSIS.md` - Section 2.2（資訊流失點分析）
- `docs/AI_APPLICATION_DESIGN_ANALYSIS.md` - Section 7.1（修復建議 Phase 1）

**相關 Epic/Stories**:
- `docs/prd/epic-10-ai-application-layer-enhancement.md`
- `docs/stories/10.1.story.md` - RuleViolation 資料結構擴展（前置依賴）

### Testing

**測試檔案位置**: `plugin-core/src/test/java/com/github/sonarqube/plugin/`

**測試框架**:
- JUnit 5 (Jupiter)
- AssertJ (流暢的斷言 API)
- Mockito (mock SensorContext, NewIssue 等)

**測試標準**:
- 整合測試覆蓋率目標: ≥ 80%
- 測試命名: `methodName_scenario_expectedBehavior`
- 測試組織: Arrange-Act-Assert (AAA) 模式
- 每個 AC 至少對應 1-2 個測試案例

**關鍵測試場景**:

1. **完整資訊傳遞測試**:
```java
@Test
void buildEnhancedIssue_withCompleteAiInfo_shouldSetAllAttributes() {
    // Arrange
    SecurityIssue issue = createSecurityIssueWithCodeExample();
    SensorContext mockContext = mockSensorContextWithAttributeSupport();

    // Act
    NewIssue result = sensor.buildEnhancedIssue(mockContext, file, issue, rule);

    // Assert
    verify(result).attribute("ai.code.before", issue.getCodeExample().getBefore());
    verify(result).attribute("ai.code.after", issue.getCodeExample().getAfter());
    verify(result).attribute("ai.effort.estimate", issue.getEffortEstimate());
    verify(result).attribute("ai.enhanced", "true");
}
```

2. **降級模式測試**:
```java
@Test
void buildEnhancedIssue_withOldSonarQubeVersion_shouldUseLegacyMessage() {
    // Arrange
    SecurityIssue issue = createSecurityIssueWithCodeExample();
    SensorContext mockContext = mockSensorContextWithoutAttributeSupport();

    // Act
    NewIssue result = sensor.buildEnhancedIssue(mockContext, file, issue, rule);

    // Assert
    verify(result, never()).attribute(anyString(), anyString());
    verify(result).at(argThat(location ->
        location.message().contains("程式碼範例（修復前）") &&
        location.message().contains("工作量評估")
    ));
}
```

3. **空值處理測試**:
```java
@Test
void buildEnhancedIssue_withNullCodeExample_shouldNotSetCodeAttributes() {
    // Arrange
    SecurityIssue issue = createSecurityIssueWithoutCodeExample();
    SensorContext mockContext = mockSensorContextWithAttributeSupport();

    // Act
    NewIssue result = sensor.buildEnhancedIssue(mockContext, file, issue, rule);

    // Assert
    verify(result, never()).attribute(eq("ai.code.before"), anyString());
    verify(result, never()).attribute(eq("ai.code.after"), anyString());
    verify(result).attribute("ai.enhanced", "true"); // Still marked as AI-enhanced
}
```

4. **字串截斷測試**:
```java
@Test
void buildEnhancedIssue_withLongCodeExample_shouldTruncateAndWarn() {
    // Arrange
    String longCode = "x".repeat(5000);
    SecurityIssue issue = createSecurityIssueWithLongCode(longCode);
    SensorContext mockContext = mockSensorContextWithAttributeSupport();

    // Act
    NewIssue result = sensor.buildEnhancedIssue(mockContext, file, issue, rule);

    // Assert
    ArgumentCaptor<String> codeCaptor = ArgumentCaptor.forClass(String.class);
    verify(result).attribute(eq("ai.code.before"), codeCaptor.capture());
    assertThat(codeCaptor.getValue()).hasSize(4000);
    assertThat(codeCaptor.getValue()).endsWith("...");
    // Verify warning was logged
}
```

5. **錯誤處理測試**:
```java
@Test
void buildEnhancedIssue_whenAttributeSettingFails_shouldNotThrowException() {
    // Arrange
    SecurityIssue issue = createSecurityIssueWithCodeExample();
    SensorContext mockContext = mockSensorContextWithAttributeSupport();
    NewIssue mockIssue = mock(NewIssue.class);
    when(mockIssue.attribute(anyString(), anyString())).thenThrow(new RuntimeException("Attribute error"));

    // Act & Assert
    assertThatCode(() -> {
        sensor.buildEnhancedIssue(mockContext, file, issue, rule);
    }).doesNotThrowAnyException();
    // Verify warning was logged
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | 初始 Story 建立 | Scrum Master (Bob) |

## Dev Agent Record

<!-- This section will be populated by the Dev Agent during implementation -->

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

<!-- This section will be populated by the QA Agent -->

_To be filled by QA Agent_
