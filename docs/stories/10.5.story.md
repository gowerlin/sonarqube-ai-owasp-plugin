# Story 10.5: 更新 OWASP 規則啟用 AI 增強

<!-- Source: docs/prd/epic-10-ai-application-layer-enhancement.md -->

## Status

Draft

## Story

**As a** security analyst,
**I want** all 10 OWASP 2021 rules to leverage AI-powered enhancements,
**so that** I can receive intelligent fix suggestions with code examples and effort estimates for all detected vulnerabilities.

## Epic Context

**Epic**: Epic 10 - AI 應用層增強與修復

**Prerequisites**:
- Story 10.1 完成（RuleViolation 資料結構擴展）
- Story 10.2 完成（OwaspSensor 保留完整 AI 資訊）
- Story 10.3 完成（基礎資訊傳遞測試）
- Story 10.4 完成（AbstractOwaspRule AI 增強邏輯實作）

**Background**: 根據 `docs/AI_APPLICATION_DESIGN_ANALYSIS.md` Section 2.3，所有 10 個 OWASP 2021 規則的 `requiresAi()` 都返回 `false`，未實際使用 AI 增強功能。本 story 將所有規則啟用 AI 增強。

## Acceptance Criteria

1. **AC1**: 修改所有 10 個 OWASP 2021 規則的 `requiresAi()` 方法返回 `true`：
   - InjectionRule
   - BrokenAccessControlRule
   - CryptographicFailuresRule
   - AuthenticationFailuresRule
   - DataIntegrityFailuresRule
   - InsecureDesignRule
   - SecurityMisconfigurationRule
   - SecurityLoggingFailuresRule
   - SsrfRule
   - VulnerableComponentsRule

2. **AC2**: 驗證所有規則正確呼叫繼承的 `enhanceViolationsWithAi()` 方法：
   - 移除所有規則中的空 `enhanceViolationsWithAi()` override（如果有）
   - 確認規則使用基礎類別的 AI 增強邏輯
   - 驗證 AI 增強在規則執行時被觸發

3. **AC3**: 分階段啟用規則（優先級）：
   - **Phase A**: 高風險規則（優先啟用）
     - InjectionRule (A03:2021)
     - BrokenAccessControlRule (A01:2021)
     - AuthenticationFailuresRule (A07:2021)
   - **Phase B**: 中風險規則
     - CryptographicFailuresRule (A02:2021)
     - InsecureDesignRule (A04:2021)
     - SecurityMisconfigurationRule (A05:2021)
   - **Phase C**: 其他規則
     - DataIntegrityFailuresRule (A08:2021)
     - SecurityLoggingFailuresRule (A09:2021)
     - SsrfRule (A10:2021)
     - VulnerableComponentsRule (A06:2021)

4. **AC4**: 配置選項實作：
   - 新增插件配置：`ai.enhancement.enabled`（預設 true）
   - 新增規則級配置：`ai.enhancement.rules.{ruleKey}`（預設 true）
   - 允許用戶選擇性停用特定規則的 AI 增強
   - 配置變更無需重啟 SonarQube

5. **AC5**: 整合測試覆蓋率：
   - 每個規則至少 3 個測試案例：
     - 基本 AI 增強測試
     - AI 失敗降級測試
     - 配置停用測試
   - 端到端測試：完整掃描流程驗證
   - 測試覆蓋率 ≥ 80%

## Integration Verification

**IV1**: 執行 `rules-engine` 模組的整合測試，確認所有 10 個規則的 AI 增強正常運作。
```bash
mvn clean verify -pl rules-engine
```

**IV2**: 手動測試：選擇 3 個高風險規則（Phase A），使用真實 AI 服務執行完整掃描。

**IV3**: 配置測試：驗證 `ai.enhancement.enabled=false` 時，所有規則降級為無 AI 模式。

**IV4**: 效能測試：使用啟用 AI 的規則掃描大型專案（≥100 檔案），記錄效能指標。

## Tasks / Subtasks

- [ ] **Task 1**: 分析現有規則結構（準備工作）
  - [ ] 使用 Grep 搜尋所有 `requiresAi()` 方法實作
  - [ ] 使用 Grep 搜尋所有 `enhanceViolationsWithAi()` override
  - [ ] 記錄每個規則的當前狀態
  - [ ] 識別需要修改的規則檔案清單

- [ ] **Task 2**: Phase A - 啟用高風險規則 AI 增強（AC1, AC2, AC3）
  - [ ] **InjectionRule** (A03:2021):
    - [ ] 修改 `requiresAi()` 返回 `true`
    - [ ] 移除空 `enhanceViolationsWithAi()` override（如果有）
    - [ ] 撰寫 3 個整合測試案例
    - [ ] 驗證 AI 增強正常運作
  - [ ] **BrokenAccessControlRule** (A01:2021):
    - [ ] 修改 `requiresAi()` 返回 `true`
    - [ ] 移除空 `enhanceViolationsWithAi()` override（如果有）
    - [ ] 撰寫 3 個整合測試案例
    - [ ] 驗證 AI 增強正常運作
  - [ ] **AuthenticationFailuresRule** (A07:2021):
    - [ ] 修改 `requiresAi()` 返回 `true`
    - [ ] 移除空 `enhanceViolationsWithAi()` override（如果有）
    - [ ] 撰寫 3 個整合測試案例
    - [ ] 驗證 AI 增強正常運作

- [ ] **Task 3**: Phase B - 啟用中風險規則 AI 增強（AC1, AC2, AC3）
  - [ ] **CryptographicFailuresRule** (A02:2021)
  - [ ] **InsecureDesignRule** (A04:2021)
  - [ ] **SecurityMisconfigurationRule** (A05:2021)
  - （每個規則重複 Phase A 的 4 個步驟）

- [ ] **Task 4**: Phase C - 啟用其他規則 AI 增強（AC1, AC2, AC3）
  - [ ] **DataIntegrityFailuresRule** (A08:2021)
  - [ ] **SecurityLoggingFailuresRule** (A09:2021)
  - [ ] **SsrfRule** (A10:2021)
  - [ ] **VulnerableComponentsRule** (A06:2021)
  - （每個規則重複 Phase A 的 4 個步驟）

- [ ] **Task 5**: 實作配置選項（AC4）
  - [ ] 在 `PluginConfiguration` 中新增 `ai.enhancement.enabled` 配置：
    - [ ] 定義配置 key 常數
    - [ ] 實作 `isAiEnhancementEnabled()` getter 方法
    - [ ] 設定預設值為 `true`
    - [ ] 更新配置文檔
  - [ ] 實作規則級配置 `ai.enhancement.rules.{ruleKey}`：
    - [ ] 設計配置命名格式
    - [ ] 實作 `isAiEnhancementEnabledForRule(String ruleKey)` 方法
    - [ ] 設定預設值為 `true`
    - [ ] 提供配置範例

- [ ] **Task 6**: 整合配置到規則執行流程（AC4）
  - [ ] 修改 `AbstractOwaspRule.requiresAi()`：
    - [ ] 檢查全域配置 `ai.enhancement.enabled`
    - [ ] 檢查規則級配置 `ai.enhancement.rules.{ruleKey}`
    - [ ] 任一配置為 false 則返回 false
  - [ ] 更新 Javadoc 說明配置行為
  - [ ] 撰寫配置測試

- [ ] **Task 7**: 撰寫整合測試（AC5）
  - [ ] 為每個規則創建整合測試類別：
    - [ ] `{RuleName}IntegrationTest.java`
  - [ ] 每個規則實作 3 個測試案例：
    - [ ] **測試 1**: AI 增強成功
      - [ ] 提供包含漏洞的測試代碼
      - [ ] Mock AI 服務返回增強資料
      - [ ] 驗證 RuleViolation 包含 codeExample 和 effortEstimate
    - [ ] **測試 2**: AI 失敗降級
      - [ ] Mock AI 服務拋出異常
      - [ ] 驗證規則返回原始 violations
      - [ ] 驗證警告日誌正確記錄
    - [ ] **測試 3**: 配置停用
      - [ ] 設定 `ai.enhancement.enabled=false`
      - [ ] 驗證規則不呼叫 AI 服務
      - [ ] 驗證 requiresAi() 返回 false

- [ ] **Task 8**: 端到端測試（AC5）
  - [ ] 創建端到端測試專案：
    - [ ] 包含 Java 範例檔案（每個規則至少 1 個漏洞）
    - [ ] 包含 JavaScript 範例檔案（如適用）
  - [ ] 執行完整掃描流程：
    - [ ] 啟用所有 10 個規則
    - [ ] 使用真實 AI 服務（或 mock）
    - [ ] 驗證所有規則的 AI 增強正常運作
  - [ ] 記錄測試結果：
    - [ ] 每個規則偵測到的 violations 數量
    - [ ] AI 增強成功率
    - [ ] 總掃描時間

- [ ] **Task 9**: 效能測試與優化（IV4）
  - [ ] 準備測試資料集：≥100 個 Java 檔案
  - [ ] 執行基準測試：
    - [ ] 測試 1: AI 增強停用（baseline）
    - [ ] 測試 2: AI 增強啟用（Phase A 規則）
    - [ ] 測試 3: AI 增強啟用（所有規則）
  - [ ] 記錄效能指標：
    - [ ] 掃描總時間
    - [ ] AI 呼叫次數
    - [ ] 快取命中率
    - [ ] 記憶體使用量
  - [ ] 分析效能瓶頸並優化

- [ ] **Task 10**: 更新文檔
  - [ ] 更新規則文檔：說明 AI 增強功能
  - [ ] 更新配置文檔：
    - [ ] `ai.enhancement.enabled` 全域開關
    - [ ] `ai.enhancement.rules.{ruleKey}` 規則級開關
    - [ ] 配置範例
  - [ ] 更新 README：說明 AI 增強覆蓋率（10/10 規則）
  - [ ] 撰寫遷移指南：如何從舊版本升級

- [ ] **Task 11**: 執行整合驗證（IV1-IV4）
  - [ ] 執行 `mvn clean verify -pl rules-engine`
  - [ ] 手動測試 Phase A 規則（3 個高風險規則）
  - [ ] 配置測試：驗證停用功能正常
  - [ ] 效能測試：大型專案掃描
  - [ ] 修復發現的問題
  - [ ] 確認測試覆蓋率 ≥ 80%

## Dev Notes

### 檔案位置

**受影響的規則檔案**（需修改）:
- `rules-engine/src/main/java/com/github/sonarqube/rules/owasp2021/InjectionRule.java`
- `rules-engine/src/main/java/com/github/sonarqube/rules/owasp2021/BrokenAccessControlRule.java`
- `rules-engine/src/main/java/com/github/sonarqube/rules/owasp2021/CryptographicFailuresRule.java`
- `rules-engine/src/main/java/com/github/sonarqube/rules/owasp2021/AuthenticationFailuresRule.java`
- `rules-engine/src/main/java/com/github/sonarqube/rules/owasp2021/DataIntegrityFailuresRule.java`
- `rules-engine/src/main/java/com/github/sonarqube/rules/owasp2021/InsecureDesignRule.java`
- `rules-engine/src/main/java/com/github/sonarqube/rules/owasp2021/SecurityMisconfigurationRule.java`
- `rules-engine/src/main/java/com/github/sonarqube/rules/owasp2021/SecurityLoggingFailuresRule.java`
- `rules-engine/src/main/java/com/github/sonarqube/rules/owasp2021/SsrfRule.java`
- `rules-engine/src/main/java/com/github/sonarqube/rules/owasp2021/VulnerableComponentsRule.java`

**配置檔案**（需修改）:
- `plugin-core/src/main/java/com/github/sonarqube/config/PluginConfiguration.java`

**測試檔案**（需創建）:
- `rules-engine/src/test/java/com/github/sonarqube/rules/owasp2021/{RuleName}IntegrationTest.java`（每個規則）
- `rules-engine/src/test/java/com/github/sonarqube/rules/integration/AllRulesE2ETest.java`（端到端測試）

### 設計考量

**1. requiresAi() 方法修改策略**:

**修改前**（所有規則）:
```java
@Override
public boolean requiresAi() {
    return false; // ❌ 未使用 AI
}
```

**修改後**（整合配置）:
```java
@Override
public boolean requiresAi() {
    // 檢查全域配置
    if (!config.isAiEnhancementEnabled()) {
        return false;
    }

    // 檢查規則級配置
    if (!config.isAiEnhancementEnabledForRule(getRuleKey())) {
        return false;
    }

    return true; // ✅ 啟用 AI 增強
}
```

**2. enhanceViolationsWithAi() 處理**:

**現狀分析**:
- 所有 10 個規則都有空 `enhanceViolationsWithAi()` override
- 這些 override 需要移除，讓規則使用基礎類別的實作

**修改策略**:
```java
// ❌ 移除這個空 override
@Override
protected List<RuleResult.RuleViolation> enhanceViolationsWithAi(
    RuleContext context,
    List<RuleResult.RuleViolation> violations
) {
    // AI 增強邏輯可以在這裡實作
    // 目前返回原始違規列表
    return violations;
}

// ✅ 讓規則使用基礎類別的 enhanceViolationsWithAi() 實作
// （不需要 override，直接繼承 AbstractOwaspRule 的實作）
```

**3. 配置系統設計**:

**全域配置**:
```java
// PluginConfiguration.java
public class PluginConfiguration {
    private static final String AI_ENHANCEMENT_ENABLED_KEY = "ai.enhancement.enabled";

    public boolean isAiEnhancementEnabled() {
        return settings.getBoolean(AI_ENHANCEMENT_ENABLED_KEY).orElse(true);
    }
}
```

**規則級配置**:
```java
// PluginConfiguration.java
public boolean isAiEnhancementEnabledForRule(String ruleKey) {
    String configKey = "ai.enhancement.rules." + ruleKey;
    return settings.getBoolean(configKey).orElse(true);
}
```

**配置範例** (`sonar-project.properties`):
```properties
# 全域停用 AI 增強
ai.enhancement.enabled=false

# 僅停用特定規則的 AI 增強
ai.enhancement.rules.injection=false
ai.enhancement.rules.broken-access-control=false
```

**4. 分階段啟用策略**:

**Phase A**: 高風險規則（優先處理）
- **理由**: 這些規則對應的漏洞風險最高，AI 增強帶來的價值最大
- **規則**:
  - InjectionRule (A03:2021) - SQL Injection, XSS, Command Injection
  - BrokenAccessControlRule (A01:2021) - 未授權存取
  - AuthenticationFailuresRule (A07:2021) - 身份驗證失敗

**Phase B**: 中風險規則
- **理由**: 重要但較不緊急的安全問題
- **規則**:
  - CryptographicFailuresRule (A02:2021)
  - InsecureDesignRule (A04:2021)
  - SecurityMisconfigurationRule (A05:2021)

**Phase C**: 其他規則
- **理由**: 較低風險或較特定的安全問題
- **規則**:
  - DataIntegrityFailuresRule (A08:2021)
  - SecurityLoggingFailuresRule (A09:2021)
  - SsrfRule (A10:2021)
  - VulnerableComponentsRule (A06:2021)

**5. 測試策略**:

**每個規則的測試結構**:
```java
public class InjectionRuleIntegrationTest {

    @Test
    void testAiEnhancement_withSqlInjection_shouldProvideCodeExample() {
        // Arrange: 準備包含 SQL Injection 的測試代碼
        String vulnerableCode = """
            String sql = "SELECT * FROM users WHERE id = " + userId;
            Statement stmt = connection.createStatement();
            ResultSet rs = stmt.executeQuery(sql);
            """;

        // Mock AI service to return enhancement
        mockAiService.setResponse(createEnhancedResponse());

        // Act: 執行規則
        RuleResult result = rule.execute(createContext(vulnerableCode));

        // Assert: 驗證 AI 增強
        assertThat(result.getViolations()).hasSize(1);
        RuleViolation violation = result.getViolations().get(0);

        assertThat(violation.getCodeExample()).isNotNull();
        assertThat(violation.getCodeExample().getBefore()).contains("String sql =");
        assertThat(violation.getCodeExample().getAfter()).contains("PreparedStatement");
        assertThat(violation.getEffortEstimate()).isEqualTo("Simple (0.5-1 hour)");
    }

    @Test
    void testAiEnhancement_whenAiFails_shouldFallbackToOriginal() {
        // Arrange: Mock AI failure
        mockAiService.throwException(new AiException("Service unavailable"));

        // Act
        RuleResult result = rule.execute(createContext(vulnerableCode));

        // Assert: 應該返回原始 violation（無 AI 增強）
        assertThat(result.getViolations()).hasSize(1);
        RuleViolation violation = result.getViolations().get(0);

        assertThat(violation.getCodeExample()).isNull();
        assertThat(violation.getEffortEstimate()).isNull();
    }

    @Test
    void testAiEnhancement_whenDisabledByConfig_shouldNotCallAi() {
        // Arrange: 停用 AI 增強
        config.set("ai.enhancement.enabled", false);

        // Act
        RuleResult result = rule.execute(createContext(vulnerableCode));

        // Assert: 驗證未呼叫 AI
        verify(mockAiService, never()).analyzeCode(any());
    }
}
```

### 規則修改清單

| 規則名稱 | 檔案路徑 | OWASP 分類 | Phase | 修改內容 |
|---------|---------|-----------|-------|---------|
| InjectionRule | `rules/owasp2021/InjectionRule.java` | A03:2021 | A | `requiresAi() = true`, 移除空 override |
| BrokenAccessControlRule | `rules/owasp2021/BrokenAccessControlRule.java` | A01:2021 | A | 同上 |
| AuthenticationFailuresRule | `rules/owasp2021/AuthenticationFailuresRule.java` | A07:2021 | A | 同上 |
| CryptographicFailuresRule | `rules/owasp2021/CryptographicFailuresRule.java` | A02:2021 | B | 同上 |
| InsecureDesignRule | `rules/owasp2021/InsecureDesignRule.java` | A04:2021 | B | 同上 |
| SecurityMisconfigurationRule | `rules/owasp2021/SecurityMisconfigurationRule.java` | A05:2021 | B | 同上 |
| DataIntegrityFailuresRule | `rules/owasp2021/DataIntegrityFailuresRule.java` | A08:2021 | C | 同上 |
| SecurityLoggingFailuresRule | `rules/owasp2021/SecurityLoggingFailuresRule.java` | A09:2021 | C | 同上 |
| SsrfRule | `rules/owasp2021/SsrfRule.java` | A10:2021 | C | 同上 |
| VulnerableComponentsRule | `rules/owasp2021/VulnerableComponentsRule.java` | A06:2021 | C | 同上 |

### 相關資源

**參考文件**:
- `docs/AI_APPLICATION_DESIGN_ANALYSIS.md` - Section 2.3（規則引擎未使用 AI）
- `docs/prd/epic-10-ai-application-layer-enhancement.md` - Epic 10 整體需求
- `docs/stories/10.4.story.md` - AbstractOwaspRule AI 增強邏輯（前置依賴）

**OWASP Top 10 2021 參考**:
- https://owasp.org/Top10/

### Testing

**測試框架**:
- JUnit 5 (Jupiter)
- AssertJ (流暢的斷言 API)
- Mockito (Mock framework)
- Spring Boot Test (整合測試支援)

**測試覆蓋率目標**: ≥ 80%

**測試命名規範**:
```
testAiEnhancement_{scenario}_{expectedBehavior}
```

**關鍵測試場景**:

1. **AI 增強成功測試**（每個規則）:
```java
@Test
void testAiEnhancement_withVulnerability_shouldProvideEnhancedSuggestion() {
    // 驗證 AI 增強正常運作
    // 驗證 codeExample 和 effortEstimate 存在
}
```

2. **AI 失敗降級測試**（每個規則）:
```java
@Test
void testAiEnhancement_whenAiFails_shouldReturnOriginalViolation() {
    // 驗證 AI 失敗時降級行為
}
```

3. **配置停用測試**（每個規則）:
```java
@Test
void testAiEnhancement_whenDisabled_shouldNotCallAi() {
    // 驗證配置停用功能
}
```

4. **端到端測試**（所有規則）:
```java
@Test
void testAllRulesE2E_withRealProject_shouldDetectAndEnhanceVulnerabilities() {
    // 驗證所有規則在真實場景中正常運作
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | 初始 Story 建立 | Scrum Master (Bob) |

## Dev Agent Record

<!-- This section will be populated by the Dev Agent during implementation -->

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

<!-- This section will be populated by the QA Agent -->

_To be filled by QA Agent_
