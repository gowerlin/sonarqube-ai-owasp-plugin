# Story 10.3: 基礎資訊傳遞測試

<!-- Source: docs/prd/epic-10-ai-application-layer-enhancement.md -->

## Status

Draft

## Story

**As a** quality engineer,
**I want** comprehensive end-to-end testing to verify AI information flows completely from API to SonarQube Issues,
**so that** we can confidently ensure no information loss occurs and the system meets performance requirements.

## Epic Context

**Epic**: Epic 10 - AI 應用層增強與修復

**Prerequisites**:
- Story 10.1 完成（RuleViolation 資料結構擴展）
- Story 10.2 完成（OwaspSensor 保留完整 AI 資訊）

**Background**: 根據 `docs/AI_APPLICATION_DESIGN_ANALYSIS.md`，修復前 AI 提供的 8 個欄位中有 2 個（codeExample, effortEstimate）完全丟失。此 story 驗證修復後這些欄位完整傳遞到 SonarQube。

## Acceptance Criteria

1. **AC1**: 端到端測試涵蓋完整資訊流動鏈：
   - AI API 呼叫 → AiResponse
   - AiResponse → SecurityIssue（8 個欄位）
   - SecurityIssue → RuleViolation（6 個欄位 + codeExample + effortEstimate）
   - RuleViolation → SonarQube NewIssue（含 Attributes）
   - 驗證每個階段資料完整性

2. **AC2**: 驗證 SecurityIssue 的 8 個欄位全部保留：
   - `owaspCategory` ✅
   - `cweId` ✅
   - `severity` ✅
   - `description` ✅
   - `lineNumber` ✅
   - `fixSuggestion` ✅
   - `codeExample.before` ✅（重點）
   - `codeExample.after` ✅（重點）
   - `effortEstimate` ✅（重點）

3. **AC3**: 測試極端情況和邊界條件：
   - 空值測試：codeExample = null, effortEstimate = null
   - 超長文字：codeExample.before 超過 4000 字元
   - 特殊字元：HTML 標籤、換行符號、引號、Unicode 字元
   - 空字串：description = "", fixSuggestion = ""

4. **AC4**: 效能基準測試：
   - 測量修改前後的掃描時間
   - 100 個檔案的掃描時間對比
   - 驗證效能衰退 < 10%
   - 記錄記憶體使用量變化

5. **AC5**: 測試覆蓋率要求：
   - 整合測試覆蓋率 ≥ 80%
   - 端到端測試至少 5 個完整場景
   - 每個 AC 至少對應 2 個測試案例

## Integration Verification

**IV1**: 執行完整的整合測試套件，確認所有測試通過。
```bash
mvn clean verify -pl plugin-core,ai-connector,rules-engine
```

**IV2**: 手動驗證：使用真實 AI API 執行掃描，檢查 SonarQube UI 顯示。

**IV3**: 效能測試：執行基準測試腳本，驗證效能衰退 < 10%。

**IV4**: 邊界測試：使用測試資料集執行極端情況測試，確認所有邊界條件處理正確。

## Tasks / Subtasks

- [ ] **Task 1**: 建立測試基礎設施（AC1）
  - [ ] 創建 `plugin-core/src/test/java/com/github/sonarqube/plugin/integration/` 目錄
  - [ ] 創建 `AiInformationFlowIntegrationTest.java` 測試類別
  - [ ] 設定測試用 SonarQube 環境（embedded mode）
  - [ ] Mock AI API 服務提供測試資料
  - [ ] 創建測試用專案結構（包含範例 Java/JavaScript 檔案）

- [ ] **Task 2**: 實作端到端資訊流動測試（AC1, AC2）
  - [ ] 測試 AI API → AiResponse 轉換
  - [ ] 測試 AiResponse → SecurityIssue 轉換
  - [ ] 測試 SecurityIssue → RuleViolation 轉換
  - [ ] 測試 RuleViolation → SonarQube Issue 轉換
  - [ ] 驗證所有 8 個欄位在每個階段都存在
  - [ ] 驗證 Attributes 正確儲存 codeExample 和 effortEstimate

- [ ] **Task 3**: 實作極端情況測試（AC3）
  - [ ] **空值測試**:
    - [ ] 測試 codeExample = null 的情況
    - [ ] 測試 effortEstimate = null 的情況
    - [ ] 測試 description = "" 的情況
    - [ ] 驗證不會拋出 NullPointerException
  - [ ] **超長文字測試**:
    - [ ] 測試 codeExample.before 長度 5000 字元
    - [ ] 測試 effortEstimate 長度 1000 字元
    - [ ] 驗證截斷邏輯正確運作
    - [ ] 驗證警告日誌正確記錄
  - [ ] **特殊字元測試**:
    - [ ] 測試 HTML 標籤：`<script>alert('xss')</script>`
    - [ ] 測試換行符號：`\n`, `\r\n`
    - [ ] 測試引號：單引號、雙引號、反引號
    - [ ] 測試 Unicode：中文、日文、Emoji
    - [ ] 驗證特殊字元正確儲存和顯示

- [ ] **Task 4**: 實作效能基準測試（AC4）
  - [ ] 創建 `PerformanceBenchmarkTest.java` 測試類別
  - [ ] 準備測試資料集：100 個 Java 檔案
  - [ ] 實作基準測試腳本：
    - [ ] 執行修改前的版本（使用 Git tag）
    - [ ] 執行修改後的版本
    - [ ] 記錄掃描時間、記憶體使用、CPU 使用
  - [ ] 計算效能差異百分比
  - [ ] 驗證效能衰退 < 10%
  - [ ] 生成效能測試報告

- [ ] **Task 5**: 實作向後相容性測試（AC1）
  - [ ] 測試 SonarQube 9.0+ 環境（支援 Attributes）
  - [ ] 測試 SonarQube 8.x 環境（不支援 Attributes）
  - [ ] 驗證降級模式正常運作
  - [ ] 驗證降級模式下資訊仍完整（在 message 中）

- [ ] **Task 6**: 實作資料完整性驗證（AC2）
  - [ ] 創建測試輔助方法：驗證 SecurityIssue 完整性
  - [ ] 創建測試輔助方法：驗證 RuleViolation 完整性
  - [ ] 創建測試輔助方法：驗證 NewIssue Attributes 完整性
  - [ ] 實作資料一致性檢查：比對每個階段的資料
  - [ ] 生成資料流動追蹤日誌

- [ ] **Task 7**: 實作錯誤情境測試
  - [ ] 測試 AI API 呼叫失敗（網路錯誤、超時）
  - [ ] 測試 AI API 返回無效 JSON
  - [ ] 測試 AI API 返回空 issues 陣列
  - [ ] 測試 Attribute 設定失敗
  - [ ] 驗證所有錯誤情境都優雅處理（不中斷流程）

- [ ] **Task 8**: 實作測試資料管理
  - [ ] 創建測試資料 fixtures：`src/test/resources/fixtures/`
  - [ ] 創建範例 Java 檔案（包含各種安全問題）
  - [ ] 創建範例 JavaScript 檔案（包含各種安全問題）
  - [ ] 創建 AI 回應 JSON 範例（包含完整欄位）
  - [ ] 創建極端情況測試資料（空值、超長、特殊字元）

- [ ] **Task 9**: 撰寫測試文檔
  - [ ] 撰寫測試計畫文檔：測試範圍、策略、環境
  - [ ] 撰寫測試案例文檔：詳細測試步驟
  - [ ] 撰寫效能測試報告範本
  - [ ] 更新 README：如何執行整合測試

- [ ] **Task 10**: 執行整合驗證（IV1-IV4）
  - [ ] 執行 `mvn clean verify` 確認所有測試通過
  - [ ] 執行手動驗證：真實 AI API 掃描
  - [ ] 執行效能測試：驗證 < 10% 衰退
  - [ ] 執行邊界測試：極端情況處理
  - [ ] 修復發現的問題
  - [ ] 確認測試覆蓋率 ≥ 80%

## Dev Notes

### 檔案位置

**主要測試檔案**（需創建）:
- `plugin-core/src/test/java/com/github/sonarqube/plugin/integration/AiInformationFlowIntegrationTest.java`
  - 端到端資訊流動測試
- `plugin-core/src/test/java/com/github/sonarqube/plugin/integration/PerformanceBenchmarkTest.java`
  - 效能基準測試
- `plugin-core/src/test/java/com/github/sonarqube/plugin/integration/EdgeCaseIntegrationTest.java`
  - 極端情況測試

**測試資料檔案**（需創建）:
- `plugin-core/src/test/resources/fixtures/sample-vulnerable.java`
- `plugin-core/src/test/resources/fixtures/sample-vulnerable.js`
- `plugin-core/src/test/resources/fixtures/ai-response-complete.json`
- `plugin-core/src/test/resources/fixtures/ai-response-edge-cases.json`

**測試文檔**（需創建）:
- `docs/testing/integration-test-plan.md`
- `docs/testing/performance-benchmark-report.md`

### 測試策略

**1. 端到端測試架構**:

```java
@SpringBootTest
@TestPropertySource(properties = {
    "sonar.test.mode=true",
    "ai.api.mock=true"
})
public class AiInformationFlowIntegrationTest {

    @Autowired
    private AiService aiService;

    @Autowired
    private OwaspSensor owaspSensor;

    @Test
    void testCompleteInformationFlow_withAllFields_shouldPreserveAll() {
        // Arrange: 準備測試環境
        SensorContext mockContext = createMockSensorContext();
        InputFile testFile = createTestInputFile("sample-vulnerable.java");

        // Mock AI API 回應（包含完整 8 個欄位）
        mockAiApiResponse(createCompleteSecurityIssue());

        // Act: 執行完整掃描流程
        owaspSensor.execute(mockContext);

        // Assert: 驗證每個階段的資料完整性
        // Stage 1: 驗證 AI API 返回 SecurityIssue
        List<SecurityIssue> issues = aiService.analyzeCode(createTestRequest());
        assertThat(issues).hasSize(1);
        assertThat(issues.get(0).getCodeExample()).isNotNull();
        assertThat(issues.get(0).getEffortEstimate()).isNotNull();

        // Stage 2: 驗證 SecurityIssue → RuleViolation 轉換
        // (透過 spy 監控 createViolation 方法呼叫)

        // Stage 3: 驗證 RuleViolation → NewIssue 轉換
        verify(mockContext.newIssue())
            .attribute("ai.code.before", notNullValue())
            .attribute("ai.code.after", notNullValue())
            .attribute("ai.effort.estimate", notNullValue());
    }
}
```

**2. 效能測試策略**:

```java
@Test
@Tag("performance")
void performanceBenchmark_100Files_shouldMeetPerformanceRequirements() {
    // Arrange: 準備 100 個測試檔案
    List<InputFile> testFiles = createTestFileSet(100);

    // Baseline: 執行修改前的版本（如果可用）
    long baselineTime = measureScanTime(testFiles, useOldVersion());

    // Act: 執行修改後的版本
    long currentTime = measureScanTime(testFiles, useCurrentVersion());

    // Assert: 驗證效能衰退 < 10%
    double degradation = (currentTime - baselineTime) / (double) baselineTime;
    assertThat(degradation).isLessThan(0.10); // < 10%

    // Report: 記錄效能測試結果
    reportPerformanceMetrics(baselineTime, currentTime, degradation);
}

private long measureScanTime(List<InputFile> files, SensorVersion version) {
    long startTime = System.currentTimeMillis();
    // 執行掃描
    long endTime = System.currentTimeMillis();
    return endTime - startTime;
}
```

**3. 極端情況測試資料**:

```json
{
  "issues": [
    {
      "owaspCategory": "A01:2021-Broken Access Control",
      "cweId": "CWE-284",
      "severity": "HIGH",
      "description": "Access control vulnerability",
      "lineNumber": 42,
      "fixSuggestion": "Implement proper authorization checks",
      "codeExample": {
        "before": "// 超長代碼範例（5000+ 字元）\npublic void sensitiveOperation() {\n    // ... 超長代碼 ...\n}",
        "after": "// 修復後的代碼\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic void sensitiveOperation() {\n    // ... 安全代碼 ...\n}"
      },
      "effortEstimate": "Medium (2-4 hours)"
    },
    {
      "owaspCategory": "A03:2021-Injection",
      "cweId": "CWE-89",
      "severity": "CRITICAL",
      "description": "SQL injection vulnerability with special chars: <script>alert('xss')</script>\n新行測試",
      "lineNumber": 67,
      "fixSuggestion": "Use parameterized queries with 'quoted' strings",
      "codeExample": {
        "before": "String sql = \"SELECT * FROM users WHERE name = '\" + userInput + \"'\";",
        "after": "String sql = \"SELECT * FROM users WHERE name = ?\"; // Use PreparedStatement"
      },
      "effortEstimate": "Simple (0.5-1 hour) 中文測試 🔒"
    },
    {
      "owaspCategory": "A02:2021-Cryptographic Failures",
      "cweId": null,
      "severity": "MEDIUM",
      "description": null,
      "lineNumber": null,
      "fixSuggestion": "",
      "codeExample": null,
      "effortEstimate": null
    }
  ]
}
```

**4. Mock AI API 設定**:

```java
@TestConfiguration
public class MockAiServiceConfiguration {

    @Bean
    @Primary
    public AiService mockAiService() {
        AiService mock = mock(AiService.class);

        // 設定完整資料回應
        when(mock.analyzeCode(any(AiRequest.class)))
            .thenReturn(createMockAiResponse());

        return mock;
    }

    private AiResponse createMockAiResponse() {
        SecurityIssue issue = new SecurityIssue();
        issue.setOwaspCategory("A01:2021-Broken Access Control");
        issue.setCweId("CWE-284");
        issue.setSeverity(Severity.HIGH);
        issue.setDescription("Test description");
        issue.setLineNumber(42);
        issue.setFixSuggestion("Test fix suggestion");

        CodeExample codeExample = new CodeExample();
        codeExample.setBefore("vulnerable code");
        codeExample.setAfter("secure code");
        issue.setCodeExample(codeExample);

        issue.setEffortEstimate("Simple (0.5-1 hour)");

        return AiResponse.builder()
            .issues(List.of(issue))
            .success(true)
            .build();
    }
}
```

### 測試覆蓋率要求

**目標覆蓋率**: ≥ 80%

**關鍵測試區域**:
1. **資訊流動測試** (AC1, AC2): 40% 權重
   - AI API → AiResponse: 10%
   - AiResponse → SecurityIssue: 10%
   - SecurityIssue → RuleViolation: 10%
   - RuleViolation → NewIssue: 10%

2. **極端情況測試** (AC3): 30% 權重
   - 空值測試: 10%
   - 超長文字測試: 10%
   - 特殊字元測試: 10%

3. **效能測試** (AC4): 15% 權重
   - 基準測試: 10%
   - 效能對比: 5%

4. **錯誤處理測試**: 15% 權重
   - API 錯誤: 5%
   - 資料錯誤: 5%
   - 系統錯誤: 5%

### Testing

**測試框架**:
- JUnit 5 (Jupiter)
- AssertJ (流暢的斷言 API)
- Mockito (Mock framework)
- Spring Boot Test (整合測試支援)
- JMH (效能測試，可選)

**測試命名規範**:
```
methodName_scenario_expectedBehavior
```

**範例測試案例**:

```java
@Test
void analyzeFile_withCompleteAiResponse_shouldPreserveAllEightFields() {
    // Arrange
    InputFile testFile = createTestInputFile();
    mockAiResponseWithAllFields();

    // Act
    List<SecurityIssue> issues = sensor.analyzeFile(testFile);

    // Assert
    assertThat(issues).hasSize(1);
    SecurityIssue issue = issues.get(0);

    assertThat(issue.getOwaspCategory()).isEqualTo("A01:2021-Broken Access Control");
    assertThat(issue.getCweId()).isEqualTo("CWE-284");
    assertThat(issue.getSeverity()).isEqualTo(Severity.HIGH);
    assertThat(issue.getDescription()).isNotBlank();
    assertThat(issue.getLineNumber()).isEqualTo(42);
    assertThat(issue.getFixSuggestion()).isNotBlank();

    // 重點：驗證新增欄位
    assertThat(issue.getCodeExample()).isNotNull();
    assertThat(issue.getCodeExample().getBefore()).isNotBlank();
    assertThat(issue.getCodeExample().getAfter()).isNotBlank();
    assertThat(issue.getEffortEstimate()).isEqualTo("Simple (0.5-1 hour)");
}

@Test
void buildEnhancedIssue_withNullCodeExample_shouldNotSetCodeAttributes() {
    // Arrange
    SecurityIssue issueWithoutCode = createIssueWithoutCodeExample();

    // Act
    NewIssue result = sensor.buildEnhancedIssue(context, file, issueWithoutCode, rule);

    // Assert
    verify(result, never()).attribute(eq("ai.code.before"), anyString());
    verify(result, never()).attribute(eq("ai.code.after"), anyString());
    verify(result).attribute("ai.enhanced", "true"); // Still marked as AI
}

@Test
void buildEnhancedIssue_withExtremelyLongCode_shouldTruncateAndLogWarning() {
    // Arrange
    String longCode = "x".repeat(5000);
    SecurityIssue issue = createIssueWithLongCode(longCode);

    // Act
    NewIssue result = sensor.buildEnhancedIssue(context, file, issue, rule);

    // Assert
    ArgumentCaptor<String> codeCaptor = ArgumentCaptor.forClass(String.class);
    verify(result).attribute(eq("ai.code.before"), codeCaptor.capture());

    String capturedCode = codeCaptor.getValue();
    assertThat(capturedCode).hasSizeLessThanOrEqualTo(4000);
    assertThat(capturedCode).endsWith("...");

    // Verify warning log
    // (使用 LogCaptor 或類似工具驗證)
}

@Test
void buildEnhancedIssue_withSpecialCharacters_shouldPreserveCorrectly() {
    // Arrange
    String specialChars = "<script>alert('xss')</script>\n測試\"引號\"";
    SecurityIssue issue = createIssueWithSpecialChars(specialChars);

    // Act
    NewIssue result = sensor.buildEnhancedIssue(context, file, issue, rule);

    // Assert
    ArgumentCaptor<String> descCaptor = ArgumentCaptor.forClass(String.class);
    verify(result.newLocation()).message(descCaptor.capture());

    String message = descCaptor.getValue();
    assertThat(message).contains("<script>");
    assertThat(message).contains("測試");
    assertThat(message).contains("引號");
}
```

### 效能測試範例

```java
@Test
@Tag("performance")
void performanceTest_100FilesWithAiEnhancement_shouldMeetRequirements() {
    // Arrange: 準備測試環境
    List<InputFile> testFiles = IntStream.range(0, 100)
        .mapToObj(i -> createTestInputFile("TestFile" + i + ".java"))
        .collect(Collectors.toList());

    SensorContext context = createTestSensorContext();

    // Mock AI 服務返回標準回應
    when(aiService.analyzeCode(any())).thenReturn(createStandardAiResponse());

    // Act: 測量執行時間
    long startTime = System.nanoTime();

    for (InputFile file : testFiles) {
        sensor.execute(context);
    }

    long endTime = System.nanoTime();
    long elapsedMillis = (endTime - startTime) / 1_000_000;

    // Assert: 驗證效能要求
    // 假設基準時間為 10000ms（修改前），要求 < 11000ms（10% 衰退）
    long performanceThreshold = 11000; // 10% degradation
    assertThat(elapsedMillis).isLessThan(performanceThreshold);

    // Report
    System.out.printf("Performance Test: 100 files processed in %d ms%n", elapsedMillis);
}
```

### 相關資源

**參考文件**:
- `docs/AI_APPLICATION_DESIGN_ANALYSIS.md` - Section 2.2（資訊流失點分析）
- `docs/prd/epic-10-ai-application-layer-enhancement.md` - Epic 10 整體需求
- `docs/stories/10.1.story.md` - RuleViolation 擴展 story
- `docs/stories/10.2.story.md` - OwaspSensor 修改 story

**測試文檔範本**:
- JUnit 5 User Guide: https://junit.org/junit5/docs/current/user-guide/
- AssertJ Documentation: https://assertj.github.io/doc/
- Mockito Documentation: https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | 初始 Story 建立 | Scrum Master (Bob) |

## Dev Agent Record

<!-- This section will be populated by the Dev Agent during implementation -->

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

<!-- This section will be populated by the QA Agent -->

_To be filled by QA Agent_
