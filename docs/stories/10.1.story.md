# Story 10.1: 擴展 RuleViolation 資料結構

<!-- Source: docs/prd/epic-10-ai-application-layer-enhancement.md -->

## Status

Draft

## Story

**As a** developer implementing AI-enhanced security analysis,
**I want** RuleViolation data structure to support Before/After code examples and effort estimates,
**so that** AI-provided fix suggestions can be fully preserved and displayed to end users.

## Epic Context

**Epic**: Epic 10 - AI 應用層增強與修復

**Prerequisites**:
- Epic 2 Story 2.1-2.3 完成（AI 連接器、OpenAI 整合、提示詞工程）
- Epic 3 Story 3.1-3.2 完成（規則引擎架構、OWASP 2021 規則）

**Background**: 根據 `docs/AI_APPLICATION_DESIGN_ANALYSIS.md`，AI 提供的完整資訊（codeExample, effortEstimate）因 RuleViolation 資料結構缺少對應欄位而無法傳遞。

## Acceptance Criteria

1. **AC1**: `RuleViolation` 新增 `codeExample` 欄位（CodeExample 類型），包含 `before` 和 `after` 兩個字串欄位。

2. **AC2**: `RuleViolation` 新增 `effortEstimate` 欄位（String 類型），用於儲存工作量評估文字（例如："Simple (0.5-1 hour)"）。

3. **AC3**: `RuleViolation.ViolationBuilder` 支援新欄位的設定，包含 `codeExample(CodeExample)` 和 `effortEstimate(String)` 方法。

4. **AC4**: 向後相容性：新欄位為可選（nullable），現有程式碼不設定這些欄位時不會發生錯誤。

5. **AC5**: 單元測試覆蓋率 ≥ 85%，包含：
   - 建立包含完整欄位的 RuleViolation
   - 建立僅包含基本欄位的 RuleViolation（測試向後相容）
   - 測試空值、超長文字、特殊字元的處理

## Integration Verification

**IV1**: 執行 `rules-engine` 模組的單元測試，確認所有測試通過且新測試覆蓋率 ≥ 85%。

**IV2**: 執行 Maven 建置 `mvn clean test -pl rules-engine`，確認編譯無錯誤且測試通過。

**IV3**: 驗證現有使用 `RuleViolation` 的程式碼（如 `AbstractOwaspRule.createViolation()`）仍能正常運作（向後相容）。

## Tasks / Subtasks

- [ ] **Task 1**: 擴展 CodeExample 類別（AC1）
  - [ ] 在 `SecurityIssue.java` 中檢查現有 `CodeExample` 類別實作
  - [ ] 如需要，創建獨立的 `CodeExample` 類別於 `rules-engine` 模組
  - [ ] 實作 `getBefore()` 和 `getAfter()` 方法
  - [ ] 實作 `equals()` 和 `hashCode()` 方法
  - [ ] 實作 `toString()` 方法用於除錯

- [ ] **Task 2**: 修改 RuleViolation 資料結構（AC1, AC2, AC4）
  - [ ] 在 `RuleResult.java` 的 `RuleViolation` 內部類別中新增 `codeExample` 欄位
  - [ ] 新增 `effortEstimate` 欄位
  - [ ] 更新 `ViolationBuilder` 建構子，初始化新欄位為 `null`
  - [ ] 確保新欄位為 `final` 且透過 builder 設定
  - [ ] 更新 `toString()` 方法包含新欄位資訊

- [ ] **Task 3**: 擴展 ViolationBuilder（AC3）
  - [ ] 新增 `codeExample(CodeExample codeExample)` 方法
  - [ ] 新增 `effortEstimate(String effortEstimate)` 方法
  - [ ] 確保 builder 方法返回 `this` 支援 fluent API
  - [ ] 更新 `build()` 方法，將新欄位傳遞給 `RuleViolation` 建構子

- [ ] **Task 4**: 更新輔助方法（相容性）
  - [ ] 檢查 `AbstractOwaspRule.createViolation()` 系列方法
  - [ ] 確認現有 4 參數版本不受影響（向後相容）
  - [ ] 考慮新增 6 參數版本包含 `codeExample` 和 `effortEstimate`（可選）

- [ ] **Task 5**: 撰寫單元測試（AC5）
  - [ ] 測試 `RuleViolation` 包含完整欄位的建立
    - [ ] 使用 Builder 設定所有欄位（包含新欄位）
    - [ ] 驗證 `getCodeExample()` 返回正確的 CodeExample 物件
    - [ ] 驗證 `getEffortEstimate()` 返回正確的字串
  - [ ] 測試向後相容性
    - [ ] 使用舊的 4 參數 `createViolation()` 方法
    - [ ] 驗證 `getCodeExample()` 和 `getEffortEstimate()` 返回 `null`
    - [ ] 驗證不會拋出 NullPointerException
  - [ ] 測試邊界條件
    - [ ] CodeExample 的 before 或 after 為 null
    - [ ] effortEstimate 為空字串或 null
    - [ ] effortEstimate 包含超長文字（>1000 字元）
    - [ ] effortEstimate 包含特殊字元（換行、引號、HTML 標籤）
  - [ ] 測試 Builder 驗證邏輯
    - [ ] 驗證 message 欄位仍為必需（現有驗證）
    - [ ] 驗證新欄位可選（允許 null）
  - [ ] 測試 `equals()` 和 `hashCode()`
    - [ ] 兩個包含相同新欄位的 RuleViolation 應該相等
    - [ ] 新欄位不同的 RuleViolation 不應該相等

- [ ] **Task 6**: 更新 Javadoc 註釋
  - [ ] 為 `codeExample` 欄位新增清晰的 Javadoc
  - [ ] 為 `effortEstimate` 欄位新增清晰的 Javadoc
  - [ ] 更新 `RuleViolation` 類別的整體說明
  - [ ] 在 Builder 方法新增 `@param` 和 `@return` 說明

- [ ] **Task 7**: 執行整合驗證（IV1, IV2, IV3）
  - [ ] 執行 `mvn clean test -pl rules-engine`
  - [ ] 驗證測試覆蓋率 ≥ 85%（使用 JaCoCo）
  - [ ] 執行現有的 `AbstractOwaspRule` 測試確認向後相容
  - [ ] 修復任何發現的問題

## Dev Notes

### 資料模型架構

**來源**: `docs/architecture.md` - Line 407-506 (rules-engine 模組)

**RuleViolation 當前結構** (根據實際程式碼分析):
```java
// rules-engine/src/main/java/com/github/sonarqube/rules/RuleResult.java:176-261
public static class RuleViolation {
    private final int lineNumber;
    private final String message;
    private final RuleSeverity severity;
    private final String codeSnippet;
    private final String fixSuggestion;  // ✅ 現有欄位

    // ❌ 缺少以下欄位（本 story 要新增）:
    // - CodeExample codeExample
    // - String effortEstimate
}
```

**SecurityIssue 參考結構** (AI 層提供的完整資訊):
```java
// ai-connector/src/main/java/com/github/sonarqube/ai/model/SecurityIssue.java:13-215
public class SecurityIssue {
    private String owaspCategory;
    private String cweId;
    private Severity severity;
    private String description;
    private Integer lineNumber;
    private String fixSuggestion;
    private CodeExample codeExample;   // ✅ 本 story 要參考
    private String effortEstimate;     // ✅ 本 story 要參考

    // CodeExample 結構 (Line 78-118):
    public static class CodeExample {
        private String before;
        private String after;
        // + getters, setters, equals, hashCode
    }
}
```

### 檔案位置

**主要修改檔案**:
- `rules-engine/src/main/java/com/github/sonarqube/rules/RuleResult.java`
  - Line 176-261: `RuleViolation` 內部類別
  - Line 215-251: `ViolationBuilder` 內部類別

**參考檔案**:
- `ai-connector/src/main/java/com/github/sonarqube/ai/model/SecurityIssue.java`
  - Line 78-118: `CodeExample` 類別實作參考

**測試檔案** (需創建):
- `rules-engine/src/test/java/com/github/sonarqube/rules/RuleResultTest.java`
  - 測試 `RuleViolation` 的新欄位
  - 測試 Builder 模式
  - 測試向後相容性

### 設計考量

**1. CodeExample 類別複用 vs 重建**:
- **選項 A**: 複用 `ai-connector` 模組的 `SecurityIssue.CodeExample`
  - 優點：避免重複程式碼
  - 缺點：`rules-engine` 依賴 `ai-connector`（違反模組分層）
- **選項 B**: 在 `rules-engine` 模組創建獨立 `CodeExample`
  - 優點：模組獨立性，清晰的分層架構
  - 缺點：程式碼重複
- **建議**: 採用選項 B（保持模組獨立性）

**2. 向後相容性策略**:
- 新欄位必須為可選（nullable）
- 現有的 `createViolation()` 方法不需要修改
- Builder 模式允許部分欄位設定

**3. 驗證邏輯**:
- `message` 欄位仍為必需（保持現有驗證）
- `codeExample` 和 `effortEstimate` 可為 null（不驗證）

### 前一個 Story 的相關經驗

**無相關前置 story**（本 story 是 Epic 10 的第一個 story）

### Testing

**測試檔案位置**: `rules-engine/src/test/java/com/github/sonarqube/rules/`

**測試框架**:
- JUnit 5 (Jupiter)
- AssertJ (流暢的斷言 API)
- Mockito (如需 mock)

**測試標準**:
- 單元測試覆蓋率目標: ≥ 85%
- 測試命名: `methodName_scenario_expectedBehavior`
- 測試組織: Arrange-Act-Assert (AAA) 模式
- 每個 AC 至少對應 1-2 個測試案例

**關鍵測試場景**:
1. **完整欄位測試**:
   ```java
   @Test
   void buildViolation_withAllFields_shouldContainCodeExampleAndEffort() {
       CodeExample example = new CodeExample("before", "after");
       RuleViolation violation = RuleViolation.builder()
           .lineNumber(42)
           .message("Test")
           .codeExample(example)
           .effortEstimate("Simple (0.5-1 hour)")
           .build();

       assertThat(violation.getCodeExample()).isEqualTo(example);
       assertThat(violation.getEffortEstimate()).isEqualTo("Simple (0.5-1 hour)");
   }
   ```

2. **向後相容測試**:
   ```java
   @Test
   void buildViolation_withoutNewFields_shouldHaveNullValues() {
       RuleViolation violation = RuleViolation.builder()
           .lineNumber(42)
           .message("Test")
           .build();

       assertThat(violation.getCodeExample()).isNull();
       assertThat(violation.getEffortEstimate()).isNull();
   }
   ```

3. **邊界條件測試**:
   ```java
   @Test
   void buildViolation_withNullCodeExample_shouldNotThrowException() {
       assertThatCode(() -> {
           RuleViolation.builder()
               .message("Test")
               .codeExample(null)
               .build();
       }).doesNotThrowAnyException();
   }
   ```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | 初始 Story 建立 | Scrum Master (Bob) |

## Dev Agent Record

<!-- This section will be populated by the Dev Agent during implementation -->

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

<!-- This section will be populated by the QA Agent -->

_To be filled by QA Agent_
