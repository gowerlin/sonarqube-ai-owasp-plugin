# Story 1.7: Error Handling, Logging, and Performance Optimization

<!-- Source: docs/prd-pdf-enhancement/epic-1-enterprise-pdf-report-generation.md -->

## Status: Draft

## Story

As a **DevOps engineer**,
I want **PDF generation to have robust error handling, detailed logging, and optimized performance**,
so that **I can troubleshoot issues quickly and ensure reports are generated within acceptable time**.

## Epic Context

**Epic**: Epic 1 - Enterprise PDF Report Generation

**Prerequisites**: Stories 1.1-1.6 完成

## Acceptance Criteria

1. **AC1**: 實作全面的異常處理,包含:iText API 異常(`PdfException`)記錄錯誤並回傳友善錯誤訊息、Logo 檔案不存在記錄警告使用降級樣式、資料為空(`AnalysisReport` 無安全問題)生成包含「No security issues found」訊息的 PDF、記憶體不足記錄錯誤並建議減少報表大小或增加 JVM 記憶體。

2. **AC2**: 實作詳細的日誌記錄(使用 SonarQube `Loggers`),包含:INFO 級別(PDF 生成開始/完成、檔案大小、生成時間)、WARN 級別(降級處理,如 Logo 不存在、異常但可恢復的情況)、ERROR 級別(PDF 生成失敗、嚴重異常)、不記錄敏感資訊(如 PDF 內容、檔案路徑的完整絕對路徑)。

3. **AC3**: 實作效能優化:使用 iText 的串流寫入模式(`PdfWriter`),避免完整 PDF 在記憶體中建構、對大型報表(>500 個安全問題)實作分頁和記憶體限制、圖表生成使用快取(Caffeine Cache),相同資料的圖表僅生成一次。

4. **AC4**: 實作超時控制,單一 PDF 生成超過 60 秒時中斷並記錄錯誤(使用 `Future` 和 `ExecutorService`)。

5. **AC5**: 新增效能指標記錄:PDF 檔案大小、生成時間、記憶體使用(記錄於 INFO 日誌),供後續優化參考。

## Integration Verification

**IV1**: 模擬異常情況(刪除 Logo 檔案、提供空的 `AnalysisReport`),驗證 PDF 仍能生成且錯誤訊息清晰。

**IV2**: 生成包含 1000 個安全問題的大型 PDF,驗證:生成時間 < 15 秒(NFR1)、記憶體使用 < 500 MB(NFR9)、PDF 檔案大小 < 50 MB(合理範圍內)。

**IV3**: 檢查日誌輸出,確認包含關鍵資訊(生成時間、檔案大小)且無敏感資訊洩漏。

## Dev Notes

### Error Handling Patterns

```java
public String generate(AnalysisReport report) throws ReportGenerationException {
    LOG.info("Starting PDF generation for project: {}", report.getProjectName());
    long startTime = System.currentTimeMillis();

    try {
        // Validate input
        if (report.getFindings().isEmpty()) {
            LOG.warn("No security findings in report, generating empty report");
            return generateEmptyReport(report);
        }

        // Generate with timeout
        Future<String> future = executor.submit(() -> generateInternal(report));
        String result = future.get(60, TimeUnit.SECONDS);

        // Performance metrics
        long duration = System.currentTimeMillis() - startTime;
        File pdfFile = new File(result);
        long fileSize = pdfFile.length();

        LOG.info("PDF generated successfully: {} bytes in {}ms", fileSize, duration);

        return result;
    } catch (TimeoutException e) {
        LOG.error("PDF generation timeout after 60 seconds");
        throw new ReportGenerationException("PDF generation timeout", e);
    } catch (OutOfMemoryError e) {
        LOG.error("Out of memory during PDF generation. Increase JVM heap size or reduce report size.");
        throw new ReportGenerationException("Insufficient memory for PDF generation", e);
    } catch (PdfException e) {
        LOG.error("iText PDF generation error: {}", e.getMessage(), e);
        throw new ReportGenerationException("PDF generation failed", e);
    } catch (Exception e) {
        LOG.error("Unexpected error during PDF generation", e);
        throw new ReportGenerationException("PDF generation failed", e);
    }
}
```

### Performance Optimization

```java
// Stream writing (avoid in-memory construction)
try (PdfWriter writer = new PdfWriter(outputPath);
     PdfADocument pdfDoc = new PdfADocument(writer, PdfAConformanceLevel.PDF_A_1B, outputIntent);
     Document document = new Document(pdfDoc)) {

    // Enable compression
    pdfDoc.setCompressionLevel(CompressionConstants.DEFAULT_COMPRESSION);

    // Process findings in batches for large reports
    int batchSize = 100;
    for (int i = 0; i < findings.size(); i += batchSize) {
        List<SecurityFinding> batch = findings.subList(i,
            Math.min(i + batchSize, findings.size()));
        processFindingBatch(document, batch);

        // Force GC hint for large reports
        if (findings.size() > 500 && i % 500 == 0) {
            System.gc();
        }
    }
}
```

### Logging Standards

```java
// INFO - Normal operations
LOG.info("PDF generation started for project: {}", projectName);
LOG.info("Chart generation completed in {}ms", duration);
LOG.info("PDF file size: {} bytes", fileSize);

// WARN - Degraded but recoverable
LOG.warn("Logo file not found at {}, using default style", logoPath);
LOG.warn("Chart cache miss ratio: {}", cacheMissRatio);

// ERROR - Failures
LOG.error("Failed to generate PDF: {}", e.getMessage(), e);
LOG.error("Timeout after 60 seconds, aborting PDF generation");

// DO NOT log sensitive data
// ❌ LOG.info("PDF content: {}", pdfContent);
// ❌ LOG.info("Absolute path: {}", absolutePath);
```

## Tasks

1. Add comprehensive exception handling to all PDF generation methods
2. Implement timeout control with ExecutorService
3. Add performance metrics logging (duration, file size, memory)
4. Implement stream writing optimization
5. Add batch processing for large reports (>500 findings)
6. Implement memory usage monitoring
7. Add graceful degradation for missing logo
8. Create unit tests for error scenarios
9. Create performance tests with 1000 findings
10. Integration verification

## Definition of Done

- [ ] All AC met (AC1-AC5)
- [ ] All IV passed (IV1-IV3)
- [ ] Error handling comprehensive
- [ ] Logging detailed and secure (no sensitive data)
- [ ] Performance < 15s for 1000 findings
- [ ] Memory usage < 500 MB
- [ ] Timeout control working (60s limit)

---

**Previous**: Story 1.6 | **Next**: Story 1.8
