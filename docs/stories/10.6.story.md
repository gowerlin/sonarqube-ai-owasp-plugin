# Story 10.6: AI 增強整合測試與效能調優

<!-- Source: docs/prd/epic-10-ai-application-layer-enhancement.md -->

## Status

Draft

## Story

**As a** DevOps engineer and quality assurance lead,
**I want** comprehensive integration testing and performance optimization for AI-enhanced security scanning,
**so that** we can confidently deploy the system to production with acceptable performance and stability guarantees.

## Epic Context

**Epic**: Epic 10 - AI 應用層增強與修復

**Prerequisites**:
- Story 10.1 完成（RuleViolation 資料結構擴展）
- Story 10.2 完成（OwaspSensor 保留完整 AI 資訊）
- Story 10.3 完成（基礎資訊傳遞測試）
- Story 10.4 完成（AbstractOwaspRule AI 增強邏輯實作）
- Story 10.5 完成（更新 OWASP 規則啟用 AI 增強）

**Background**: 根據 `docs/prd/epic-10-ai-application-layer-enhancement.md`，本 story 是 Epic 10 的最後一個 story，確保整個 AI 增強系統在生產環境中穩定運行且效能符合要求（< 20% 衰退）。

## Acceptance Criteria

1. **AC1**: 端到端測試覆蓋完整掃描流程：
   - 準備測試專案：≥100 個檔案（Java + JavaScript）
   - 執行完整掃描：所有 10 個規則啟用 AI 增強
   - 驗證結果：所有偵測到的 violations 包含 AI 增強資訊
   - 測試覆蓋率：≥90% 的程式碼執行路徑

2. **AC2**: 效能測試與基準對比：
   - 基準測試：AI 增強停用時的掃描時間
   - 增強測試：AI 增強啟用時的掃描時間
   - 效能衰退：< 20%（增強時間 / 基準時間 - 1）
   - 記錄詳細指標：CPU、記憶體、AI 呼叫次數、快取命中率

3. **AC3**: 並行測試與執行緒安全性：
   - 多執行緒掃描測試：模擬 4 個並行掃描
   - 驗證執行緒安全：無 race conditions、deadlocks
   - 壓力測試：連續 10 次掃描無錯誤
   - 資源洩漏檢查：記憶體使用穩定，無持續增長

4. **AC4**: 快取測試與效能驗證：
   - 第一次掃描：記錄 AI 呼叫次數和時間
   - 第二次掃描（相同專案）：驗證快取命中
   - 效能提升：第二次掃描時間 ≤ 第一次的 50%
   - 快取命中率：≥70%

5. **AC5**: 錯誤恢復測試：
   - **AI API 失敗測試**：模擬 API 不可用，驗證降級行為
   - **超時測試**：模擬 AI 呼叫超時（>30 秒），驗證超時處理
   - **速率限制測試**：模擬 API 速率限制（429 Too Many Requests），驗證重試邏輯
   - **部分失敗測試**：模擬部分 violations 增強失敗，驗證混合結果正確

6. **AC6**: 負載測試與穩定性：
   - 大型專案掃描：1000 個檔案
   - 穩定性測試：連續 3 次掃描無崩潰
   - 記憶體限制：峰值記憶體使用 < 2GB
   - 掃描時間：< 30 分鐘（平均每檔案 <2 秒）

7. **AC7**: 測試報告與文檔：
   - 效能基準報告：包含詳細指標、圖表
   - 資源使用報告：CPU、記憶體、網路使用
   - 錯誤率報告：AI 失敗率、降級率、重試次數
   - 測試覆蓋率報告：≥90% 程式碼覆蓋
   - 優化建議：識別效能瓶頸並提供優化建議

## Integration Verification

**IV1**: 執行完整的整合測試套件，確認所有測試通過。
```bash
mvn clean verify -pl plugin-core,rules-engine,ai-connector
```

**IV2**: 手動執行端到端測試：使用真實 AI 服務掃描大型開源專案（如 Spring Boot）。

**IV3**: 效能測試：在標準硬體環境（4 core CPU, 8GB RAM）上執行效能測試。

**IV4**: 生成測試報告：使用 JaCoCo、JMH、VisualVM 等工具生成詳細報告。

## Tasks / Subtasks

- [ ] **Task 1**: 準備測試環境和資料集（AC1）
  - [ ] 建立測試專案結構：
    - [ ] 100 個 Java 檔案（包含各種 OWASP 漏洞）
    - [ ] 50 個 JavaScript 檔案
    - [ ] 混合真實專案程式碼和測試用例
  - [ ] 設定測試環境：
    - [ ] SonarQube 測試實例
    - [ ] Mock AI 服務（可控制回應時間和成功率）
    - [ ] 真實 AI 服務（用於端到端測試）
  - [ ] 準備基準資料：
    - [ ] 執行一次無 AI 掃描，記錄基準時間
    - [ ] 記錄預期的 violations 數量

- [ ] **Task 2**: 實作端到端測試（AC1）
  - [ ] 創建 `E2EIntegrationTest.java`：
    - [ ] 完整掃描流程測試
    - [ ] 驗證所有 10 個規則正常運作
    - [ ] 驗證 AI 增強資訊完整性
    - [ ] 驗證 SonarQube Issue 儲存正確
  - [ ] 測試場景：
    - [ ] 場景 1: SQL Injection + AI 增強
    - [ ] 場景 2: Broken Access Control + AI 增強
    - [ ] 場景 3: 多個規則觸發（混合測試）
  - [ ] 斷言驗證：
    - [ ] 所有 violations 包含 codeExample
    - [ ] 所有 violations 包含 effortEstimate
    - [ ] SonarQube Attributes 正確儲存

- [ ] **Task 3**: 實作效能測試（AC2）
  - [ ] 創建 `PerformanceBenchmarkTest.java`：
    - [ ] 使用 JMH 進行基準測試
    - [ ] 測試場景：
      - [ ] Baseline: AI 增強停用
      - [ ] AI Enhanced: AI 增強啟用
    - [ ] 記錄指標：
      - [ ] 總掃描時間
      - [ ] 平均每檔案時間
      - [ ] AI 呼叫次數
      - [ ] 快取命中率
      - [ ] CPU 使用率
      - [ ] 記憶體使用量
  - [ ] 計算效能衰退百分比：
    - [ ] 公式: (AI時間 - 基準時間) / 基準時間 * 100%
    - [ ] 驗證 < 20%
  - [ ] 生成效能報告（圖表）

- [ ] **Task 4**: 實作並行測試（AC3）
  - [ ] 創建 `ConcurrencyTest.java`：
    - [ ] 測試 1: 多執行緒掃描
      - [ ] 啟動 4 個並行掃描
      - [ ] 驗證無 race conditions
      - [ ] 驗證結果正確性
    - [ ] 測試 2: 連續掃描
      - [ ] 執行 10 次掃描
      - [ ] 驗證無記憶體洩漏
      - [ ] 記錄記憶體使用趨勢
    - [ ] 測試 3: 壓力測試
      - [ ] 同時掃描多個專案
      - [ ] 驗證系統穩定性
  - [ ] 使用 Thread Safety 分析工具（如 JCStress）
  - [ ] 使用記憶體分析工具（如 VisualVM）

- [ ] **Task 5**: 實作快取測試（AC4）
  - [ ] 創建 `CachePerformanceTest.java`：
    - [ ] 第一次掃描：
      - [ ] 記錄 AI 呼叫次數（N）
      - [ ] 記錄掃描時間（T1）
      - [ ] 記錄快取統計（0% 命中率）
    - [ ] 第二次掃描（相同專案）：
      - [ ] 記錄 AI 呼叫次數（應 << N）
      - [ ] 記錄掃描時間（T2）
      - [ ] 計算快取命中率
      - [ ] 驗證 T2 ≤ 0.5 * T1
  - [ ] 測試快取過期機制
  - [ ] 測試快取大小限制（1000 條目）

- [ ] **Task 6**: 實作錯誤恢復測試（AC5）
  - [ ] **AI API 失敗測試**:
    - [ ] Mock AI 服務返回錯誤
    - [ ] 驗證降級到原始 violations
    - [ ] 驗證警告日誌記錄
    - [ ] 驗證掃描不中斷
  - [ ] **超時測試**:
    - [ ] Mock AI 服務延遲 >30 秒
    - [ ] 驗證超時處理邏輯
    - [ ] 驗證降級行為
  - [ ] **速率限制測試**:
    - [ ] Mock AI 返回 429 狀態碼
    - [ ] 驗證重試邏輯（最多 3 次）
    - [ ] 驗證 exponential backoff
  - [ ] **部分失敗測試**:
    - [ ] Mock AI 對部分 violations 失敗
    - [ ] 驗證混合結果（成功 + 失敗）
    - [ ] 驗證結果一致性

- [ ] **Task 7**: 實作負載測試（AC6）
  - [ ] 創建 `LoadTest.java`：
    - [ ] 準備 1000 個檔案的測試專案
    - [ ] 執行完整掃描
    - [ ] 記錄效能指標：
      - [ ] 總掃描時間
      - [ ] 峰值記憶體使用
      - [ ] 平均每檔案時間
      - [ ] AI 呼叫次數
      - [ ] 錯誤率
  - [ ] 連續掃描測試：
    - [ ] 執行 3 次連續掃描
    - [ ] 驗證無崩潰
    - [ ] 驗證記憶體穩定
  - [ ] 記憶體限制驗證：
    - [ ] 使用 -Xmx2G 限制
    - [ ] 驗證不發生 OutOfMemoryError

- [ ] **Task 8**: 效能優化與調優
  - [ ] 分析效能瓶頸：
    - [ ] 使用 Profiler 識別熱點（如 YourKit, VisualVM）
    - [ ] 分析 AI 呼叫時間佔比
    - [ ] 分析快取效率
  - [ ] 優化措施：
    - [ ] 調整快取大小和過期時間
    - [ ] 優化並行處理策略
    - [ ] 減少不必要的 AI 呼叫
    - [ ] 優化代碼片段提取邏輯
  - [ ] 重新測試：
    - [ ] 驗證優化效果
    - [ ] 確保效能衰退 < 20%

- [ ] **Task 9**: 生成測試報告（AC7）
  - [ ] **效能基準報告**:
    - [ ] 使用 JMH 生成 JSON 報告
    - [ ] 轉換為 HTML/PDF 格式
    - [ ] 包含圖表：時間對比、資源使用趨勢
  - [ ] **資源使用報告**:
    - [ ] CPU 使用率曲線
    - [ ] 記憶體使用曲線
    - [ ] 網路流量統計（AI API 呼叫）
  - [ ] **錯誤率報告**:
    - [ ] AI 失敗率統計
    - [ ] 降級率統計
    - [ ] 重試次數分佈
  - [ ] **測試覆蓋率報告**:
    - [ ] 使用 JaCoCo 生成覆蓋率報告
    - [ ] 驗證 ≥90% 程式碼覆蓋
  - [ ] **優化建議**:
    - [ ] 識別效能瓶頸
    - [ ] 提供具體優化建議
    - [ ] 估算優化收益

- [ ] **Task 10**: 回歸測試（確保無破壞性變更）
  - [ ] 執行 Epic 10 之前的所有測試
  - [ ] 驗證現有功能不受影響
  - [ ] 驗證向後相容性
  - [ ] 修復任何回歸問題

- [ ] **Task 11**: 執行整合驗證（IV1-IV4）
  - [ ] 執行 `mvn clean verify` 全專案測試
  - [ ] 手動測試：使用真實 AI 掃描 Spring Boot 專案
  - [ ] 在標準硬體上執行效能測試
  - [ ] 使用 JaCoCo、JMH、VisualVM 生成報告
  - [ ] 修復發現的問題
  - [ ] 最終驗證所有 AC 通過

## Dev Notes

### 檔案位置

**測試檔案**（需創建）:
- `plugin-core/src/test/java/com/github/sonarqube/plugin/integration/E2EIntegrationTest.java`
  - 端到端整合測試
- `plugin-core/src/test/java/com/github/sonarqube/plugin/performance/PerformanceBenchmarkTest.java`
  - 效能基準測試（使用 JMH）
- `plugin-core/src/test/java/com/github/sonarqube/plugin/concurrency/ConcurrencyTest.java`
  - 並行測試
- `plugin-core/src/test/java/com/github/sonarqube/plugin/cache/CachePerformanceTest.java`
  - 快取效能測試
- `plugin-core/src/test/java/com/github/sonarqube/plugin/resilience/ErrorRecoveryTest.java`
  - 錯誤恢復測試
- `plugin-core/src/test/java/com/github/sonarqube/plugin/load/LoadTest.java`
  - 負載測試

**測試資料集**（需創建）:
- `plugin-core/src/test/resources/integration-test-project/`
  - 100+ 檔案的測試專案
- `plugin-core/src/test/resources/load-test-project/`
  - 1000 檔案的負載測試專案

**測試報告輸出**（生成）:
- `target/performance-reports/`
  - 效能基準報告
- `target/site/jacoco/`
  - 測試覆蓋率報告

### 設計考量

**1. JMH 效能測試範例**:

```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.SECONDS)
@State(Scope.Benchmark)
@Fork(value = 1, warmups = 1)
@Warmup(iterations = 2)
@Measurement(iterations = 5)
public class PerformanceBenchmarkTest {

    private SensorContext context;
    private List<InputFile> testFiles;

    @Setup
    public void setup() {
        // 準備 100 個測試檔案
        testFiles = prepareTestFiles(100);
        context = createMockSensorContext();
    }

    @Benchmark
    public void baseline_noAiEnhancement() {
        // AI 增強停用
        config.set("ai.enhancement.enabled", false);
        owaspSensor.execute(context);
    }

    @Benchmark
    public void aiEnhanced_withCaching() {
        // AI 增強啟用 + 快取
        config.set("ai.enhancement.enabled", true);
        owaspSensor.execute(context);
    }

    @TearDown
    public void teardown() {
        // 記錄快取統計
        EnhancementCache cache = owaspSensor.getCache();
        System.out.println("Cache stats: " + cache.stats());
    }
}
```

**執行**:
```bash
mvn clean verify -pl plugin-core -P benchmark
```

**2. 並行測試範例**:

```java
@Test
void testConcurrentScanning_with4Threads_shouldNotCauseRaceConditions() throws Exception {
    // Arrange: 準備 4 個獨立專案
    List<ScanProject> projects = prepareTestProjects(4);

    ExecutorService executor = Executors.newFixedThreadPool(4);
    CountDownLatch latch = new CountDownLatch(4);
    List<Future<ScanResult>> futures = new ArrayList<>();

    // Act: 並行掃描
    for (ScanProject project : projects) {
        futures.add(executor.submit(() -> {
            try {
                return owaspSensor.scanProject(project);
            } finally {
                latch.countDown();
            }
        }));
    }

    // Wait for all scans to complete
    latch.await(5, TimeUnit.MINUTES);

    // Assert: 驗證結果
    for (Future<ScanResult> future : futures) {
        ScanResult result = future.get();
        assertThat(result).isNotNull();
        assertThat(result.getViolations()).isNotEmpty();
        // Verify AI enhancement worked correctly
        assertThat(result.getViolations())
            .allMatch(v -> v.getCodeExample() != null || v.getEffortEstimate() != null);
    }

    executor.shutdown();
}
```

**3. 快取測試範例**:

```java
@Test
void testCachePerformance_secondScanShouldBeFaster() {
    // First scan: populate cache
    long startTime1 = System.currentTimeMillis();
    owaspSensor.execute(context);
    long scanTime1 = System.currentTimeMillis() - startTime1;

    // Get cache stats
    EnhancementCache cache = owaspSensor.getCache();
    CacheStats stats1 = cache.stats();
    long aiCalls1 = stats1.getMissCount(); // All misses on first scan

    // Second scan: use cache
    long startTime2 = System.currentTimeMillis();
    owaspSensor.execute(context);
    long scanTime2 = System.currentTimeMillis() - startTime2;

    CacheStats stats2 = cache.stats();
    long aiCalls2 = stats2.getMissCount() - aiCalls1; // New misses

    // Assert
    assertThat(scanTime2).isLessThan(scanTime1 * 0.5); // < 50% of first scan
    assertThat(stats2.getHitRate()).isGreaterThan(0.7); // > 70% hit rate
    assertThat(aiCalls2).isLessThan(aiCalls1 * 0.3); // < 30% of first scan AI calls
}
```

**4. 錯誤恢復測試範例**:

```java
@Test
void testErrorRecovery_whenAiApiFails_shouldFallbackGracefully() {
    // Arrange: Mock AI API failure
    when(mockAiService.analyzeCode(any()))
        .thenThrow(new AiException("Service unavailable"));

    // Act: Execute scan
    ScanResult result = owaspSensor.execute(context);

    // Assert: Should complete without throwing
    assertThat(result).isNotNull();
    assertThat(result.getViolations()).isNotEmpty();

    // Violations should not have AI enhancement (fallback)
    assertThat(result.getViolations())
        .allMatch(v -> v.getCodeExample() == null && v.getEffortEstimate() == null);

    // Verify warning was logged
    verify(mockLogger).warn(contains("AI service not available"));
}

@Test
void testErrorRecovery_whenAiApiTimesOut_shouldRetry() {
    // Arrange: Mock timeout on first call, success on retry
    when(mockAiService.analyzeCode(any()))
        .thenThrow(new TimeoutException("AI timeout"))
        .thenReturn(createMockAiResponse()); // Success on retry

    // Act
    ScanResult result = owaspSensor.execute(context);

    // Assert: Should succeed after retry
    assertThat(result.getViolations())
        .anyMatch(v -> v.getCodeExample() != null);

    // Verify retry happened
    verify(mockAiService, times(2)).analyzeCode(any());
}
```

**5. 負載測試範例**:

```java
@Test
@Tag("load-test")
void testLoadTest_with1000Files_shouldCompleteUnder30Minutes() {
    // Arrange: 準備 1000 個檔案
    List<InputFile> files = prepareTestFiles(1000);
    SensorContext context = createMockContextWithFiles(files);

    // Act: 執行掃描
    long startTime = System.currentTimeMillis();
    owaspSensor.execute(context);
    long elapsedTime = System.currentTimeMillis() - startTime;

    // Assert: 效能要求
    long maxTime = 30 * 60 * 1000; // 30 minutes
    assertThat(elapsedTime).isLessThan(maxTime);

    // Assert: 記憶體要求
    Runtime runtime = Runtime.getRuntime();
    long usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / (1024 * 1024); // MB
    assertThat(usedMemory).isLessThan(2048); // < 2GB

    // Log statistics
    System.out.printf("Scan completed in %d seconds%n", elapsedTime / 1000);
    System.out.printf("Memory used: %d MB%n", usedMemory);
}
```

**6. 效能指標收集**:

```java
public class PerformanceMetrics {
    private long scanStartTime;
    private long scanEndTime;
    private long aiCallCount;
    private long cacheHits;
    private long cacheMisses;
    private long peakMemoryUsage;

    public void recordMetrics() {
        this.scanEndTime = System.currentTimeMillis();
        this.scanTime = scanEndTime - scanStartTime;

        Runtime runtime = Runtime.getRuntime();
        this.peakMemoryUsage = (runtime.totalMemory() - runtime.freeMemory()) / (1024 * 1024);

        // Get cache stats
        CacheStats cacheStats = cache.stats();
        this.cacheHits = cacheStats.getHitCount();
        this.cacheMisses = cacheStats.getMissCount();
    }

    public void generateReport() {
        String report = String.format("""
            === Performance Report ===
            Scan Time: %d seconds
            AI Calls: %d
            Cache Hit Rate: %.2f%%
            Peak Memory: %d MB
            Average Time/File: %.2f seconds
            ==========================
            """,
            scanTime / 1000,
            aiCallCount,
            (double) cacheHits / (cacheHits + cacheMisses) * 100,
            peakMemoryUsage,
            (double) scanTime / fileCount / 1000
        );

        System.out.println(report);
        writeToFile("target/performance-reports/report.txt", report);
    }
}
```

### 效能目標

**基準值**（100 個檔案）:
- **無 AI 掃描時間**: 10 秒（假設）
- **AI 增強掃描時間**: < 12 秒（< 20% 衰退）
- **快取命中後掃描時間**: < 6 秒（< 50% 首次掃描）

**負載測試目標**（1000 個檔案）:
- **總掃描時間**: < 30 分鐘
- **平均每檔案**: < 2 秒
- **峰值記憶體**: < 2GB
- **AI 呼叫次數**: < 1000（利用快取）

**錯誤率目標**:
- **AI 失敗降級率**: < 5%
- **超時重試成功率**: > 90%
- **部分增強成功率**: > 95%

### 測試工具

**效能測試工具**:
- **JMH** (Java Microbenchmark Harness): 精確的效能基準測試
- **VisualVM**: 記憶體和 CPU profiling
- **YourKit**: 進階 profiling（可選）

**並行測試工具**:
- **JCStress**: Java Concurrency Stress tests
- **JUnit 5 @Execution(CONCURRENT)**: 並行測試執行

**覆蓋率工具**:
- **JaCoCo**: 程式碼覆蓋率報告

**報告生成**:
- **Maven Surefire Report**: 測試結果報告
- **JMH JSON Reporter**: 效能測試結果
- **Custom HTML Generator**: 整合報告生成器

### 相關資源

**參考文件**:
- `docs/AI_APPLICATION_DESIGN_ANALYSIS.md` - 完整分析報告
- `docs/prd/epic-10-ai-application-layer-enhancement.md` - Epic 10 整體需求
- `docs/stories/10.1.story.md` ~ `10.5.story.md` - 前置 stories

**測試文檔**:
- JMH Documentation: https://github.com/openjdk/jmh
- JaCoCo Documentation: https://www.jacoco.org/jacoco/trunk/doc/
- JUnit 5 User Guide: https://junit.org/junit5/docs/current/user-guide/

### Testing

**測試框架**:
- JUnit 5 (Jupiter)
- JMH (Java Microbenchmark Harness)
- AssertJ (流暢的斷言 API)
- Mockito (Mock framework)
- Awaitility (異步測試)

**測試覆蓋率目標**: ≥90%

**測試標準**:
- 每個 AC 至少對應 2 個測試案例
- 效能測試至少 5 次迭代取平均值
- 並行測試至少執行 10 次確保穩定性
- 負載測試至少執行 3 次驗證一致性

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-24 | 1.0 | 初始 Story 建立 | Scrum Master (Bob) |

## Dev Agent Record

<!-- This section will be populated by the Dev Agent during implementation -->

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

<!-- This section will be populated by the QA Agent -->

_To be filled by QA Agent_
